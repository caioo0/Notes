# 算法复杂度
---

（本学习笔记来源于[算法通关手册](https://algo.itcharge.cn/00.%E5%BA%8F%E8%A8%80/02.%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/)）

## 1.  算法复杂度简介

> **算法复杂度(Algorithm complexity):** 在问题的输入规模 $n$ 的条件下，程序的时间使用情况和空间使用情况。

「算法分析」的目的在于改进算法。

正如上文中所提到的那样：算法所追求的就是 **所需运行时间更少（时间复杂度更低）、占用内存空间更小（空间复杂度更低）**。所以进行「算法分析」，就是从运行时间情况，空间使用情况两方面对算法进行分析。

要比较两个算法的优劣通常有两种方法：

- **事后统计：** 将两个算法各编写一个可执行程序，交给计算机执行，记录下各自的运行时间和占用存储空间的实际大小，从中挑选出最好的算法。

- **预先估算：** 在算法设计出来以后，根据算法中包含的步骤，估算出算法的运行时间和占用空间。比较两个算法的估算值，从中挑选出最好的算法。

大多数情况下，我们会选择第2种方式。因为第1种方式的工作量是在太大，得不偿失。另外，即便是同一个算法，用不同的语言实现，在不同的计算机上运行，所需要的运行时间都不尽相同。所以我们一般采用**预先估算**的方法来衡量算法的好坏。

采用预先估算的方式下，编译语言、计算机运行速度都不是我们所考虑的对象。我们只关心随着问题规模n扩大时，时间开销，空间开销的增长情况。

这里的 **「问题规模n」**指的是：算法问题输入的数据量大小。对于不同的算法，定义也不相同。

- 排序算法： n 表示需要排序的元素数量。
- 查找算法： n 表示查找范围内的元素总数：比如数组大小、二维矩阵大小、字符串长度、二叉树节点数、图的节点数、图的边界点等。
- 二进制计算相关算法：n 表示二进制的开展宽度。

一般来说，问题的输入规模越接近，相应的计算成本也越接近。而随着问题输入规模的扩大，计算成本也呈上升趋势。

## 2.  时间复杂度

### 2.1 时间复杂度简介

> **时间复杂度(Time Complexity):** 在问题的输入规模为 $n$ 的条件下，算法运行所需要花费的时间，可以记作为 T(n)

时间复杂度的度量标准： **基本操作次数** ，换句话说，时间复杂度跟算法中基本操作次数的数量**正相关**。

- **基本操作：** 算法执行中的每一条语句。每一次基本操作都可在常数时间内完成。

基本操作是一个运行时间不依赖操作数的操作。

例如：两个整数相加，运行时间不依赖整数的位数，相加操作即看作基本操作。

反之，如果两个数的规模很大，相加操作依赖两个数的位数，则两个数的相加操作不是一个基本操作，则每一位数的相加操作才是一个基本操作。

```python
def algorithm(n):
    
    fact = 1
    
    for i in range(1,n+1):

        fact *= 1

    return fact

```

把上述算法中所有语句的执行次数加起来$ 1 + n + n + 1 = 2n + 2$,可以用一个函数$f(n)$来表达语句的执行次数：$f(n) = 2n + 2$。


则时间复杂度的函数可以表示为：$T(n) = O(f(n))$。它表示的是随着问题规模$n$的增大，算法执行时间的增长趋势跟$f(n)$相同。$O$是一种渐进符号，$T(n)$称作算法的 **渐进时间复杂度（Asymptotic time complexity）**,称作 **时间复杂度**。





