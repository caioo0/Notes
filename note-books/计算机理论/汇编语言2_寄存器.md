汇编语言之寄存器

## 1、寄存器

> 
>
> 1. 一个典型的cpu组成：运算器、控制器、寄存器等组成,这些器件靠内部总线相连。
>
> - 运算器进行信息处理
> - 寄存器进行信息处理
> - 控制器控制各种器件进行工作
> - 内部总线连接各种器件，在它们之间进行数据的传送
>
> 2. 内部总线和外部总线的区别：**内部总线实现CPU内部各个器件的联系，外部总线实现CPU和主板上其他器件的联系。**
>
> 3. 对于一个[汇编](https://so.csdn.net/so/search?q=汇编&spm=1001.2101.3001.7020)程序员来说，CPU中的**主要部件是寄存器**。
>
> 



## 2、通用寄存器

不同的cpu寄存器个数和解构不同，**8086CPU**有14个寄存器： AX 、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。

**8086CPU所有寄存器都是16位的**，可以存放2个字节。

**通用寄存器：** AX 、BX、CX、DX 这4个寄存器，用来存放一般性的数据。

16位结构CPU具有下面几方面的结构特性。

- 运算器一次最多可以处理16位的数据；

- 寄存器的最大宽度为16位；

- 寄存器和运算器之间的通路为16位。

  > 想一想，一个16位寄存器所能存储的数据的最大值为多少?
  >
  > 答案：2B = 2*8Bit

通用寄存器的逻辑解构及数据在其中的存放方式，以16位通用型寄存器AX为例，如图：

![image-20230629214320543](.\img\aslimg\image-20230629214320543.png)

- ![image-20230629214437006](.\img\aslimg\image-20230629214437006.png)

一个N位寄存器所能存储的数据的最大值为$2^N-1$

### 字在寄存器中的存储

出于兼容性的考虑，8086CPU可以一次性处理以下两种尺寸的数据。

- 字节：记为byte，一个字节由8个bit组成，可以存在8位寄存器中。
- 字：记为word，一个字由两个字节组成，可以存在一个16位寄存器中(16位CPU)
  

![image-20230628173615468](.\img\aslimg\image-20230628173615468.png)

8086采用小端模式：高地址存放高位字节，低地址存放低位字节。

**通用寄存器**：通常用来存放一般性的数据，有AX、BX、CX、DX，它们可分为两个可独立使用的8位寄存器，

| 16位 | 8高位 | 8低位 |
| ---- | ----- | ----- |
| AX   | AH    | AL    |
| BX   | BH    | BL    |
| CX   | CH    | CL    |
| DX   | DH    | DL    |

在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的

一个8位寄存器所能存储的数据范围是0 ~ 28-1。

## 3、8086CPU给出物理地址的方法

8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。
8086CPU又是16位结构，在内部一次性处理、传输、暂时存储的地址为16位。
从8086CPU的内部结构来看，如果将地址从内部简单地发出，那么它只能送出16位的地址，表现出的寻址能力只有64KB。
8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。

![image-20230628173743500](.\img\aslimg\image-20230628173743500.png)

当8086CPU要读写内存时：

CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址；
地址加法器将两个16位地址合成为一个20位的物理地址；
地址加法器采用物理地址 = 段地址×16 + 偏移地址的方法用段地址和偏移地址合成物理地址。

例如，8086CPU要访问地址为123C8H的内存单元，1230H左移一位(空出4位)加上00C8H合成123C8H


## 4、段寄存器

我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元，可以用分段的方式来管理内存。

用一个段存放数据，将它定义为“数据段”；

用一个段存放代码，将它定义为“代码段”；

用一个段当作栈，将它定义为“栈段”。

注意：

一个段的起始地址一定是16的倍数；
偏移地址为16位，变化范围为0-FFFFH，所以一个段的长度最大为64KB。
CPU可以用不同的段地址和偏移地址形成同一个物理地址。
段寄存器：8086CPU有4个段寄存器：CS、DS、SS、ES，提供内存单元的段地址。

### 1、CS和IP

CS为代码段寄存器，IP为指令指针寄存器，

CPU将CS、IP中的内容当作指令的段地址和偏移地址,用它们合成指令的物理地址,

CPU将CS:IP指向的内容当作指令执行。(即PC)

![image-20230628173858579](.\img\aslimg\image-20230628173858579.png)

8086CPU的工作过程简要描述

从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器；
IP=IP+所读取指令的长度，从而指向下一条指令；
执行指令。转到步骤1，重复这个过程。
在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即在8086PC机刚启动时，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。

8086CPU提供转移指令修改CS、IP的内容。

jmp 段地址:偏移地址：用指令中给出的段地址修改CS，偏移地址修改IP。如：jmp 2AE3:3

jmp 某一合法寄存器：仅修改IP的内容。如：jmp ax。在含义上好似：mov IP，ax

8086CPU不支持将数据直接送入段寄存器的操作，这属于8086CPU硬件设计

### 2、DS 和 [address]

DS寄存器：通常用来存放要访问数据的段地址

[address]表示一个偏移地址为address的内存单元，段地址默认放在ds中

通过数据段段地址和偏移地址即可定位内存单元。

```
mov bx, 1000H ;8086CPU不支持将数据直接送入段寄存器的操作

mov ds, bx ;ds存放数据段地址

mov [0], al ;将al数据（1字节）存到1000H段的0偏移地址处，即10000H

mov ax, [2] ;将数据段偏移地址2处的一个字（8086为2字节）存放到ax寄存器

add cx, [4] ;将偏移地址4处的一个字数据加上cx寄存器数据放到cx寄存器

sub dx, [6] ;dx寄存器数据减去数据段偏移地址6处的字数据存到dx

```

### 3、SS 和 SP

在基于8086CPU编程的时候，可以将一段内存当作栈来使用。

栈段寄存器SS，存放段地址，SP寄存器存放偏移地址，任意时刻，SS:SP指向栈顶元素

8086CPU中，入栈时，栈顶从高地址向低地址方向增长。

push ax表示将寄存器ax中的数据送入栈中，由两步完成。

SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；
将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。

![image-20230628174002691](.\img\aslimg\image-20230628174002691.png)

`pop ax`表示从栈顶取出数据送入ax，由以下两步完成。

1. 将SS:SP指向的内存单元处的数据送入ax中；
2. SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。

**实验**

1. 将10000H~1000FH这段空间当作栈，初始状态栈是空的；

2. 设置AX=001AH，BX=001BH；

3. 将AX、BX中的数据入栈；

4. 然后将AX、BX清零；

5. 从栈中恢复AX、BX原来的内容。

   ```
   mov ax, 1000H 
   mov ss, ax 
   mov sp, 0010H    ;初始化栈顶
   mov ax, 001AH
   mov bx, 001BH 
   
   push ax 
   push bx    ;ax、bx入栈
   
   sub ax, ax   ;将ax清零，也可以用mov ax，0，
                ;sub ax，ax的机器码为2个字节，
                ;mov ax，0的机器码为3个字节。
           
   sub bx, bx 
   
   pop bx  ;从栈中恢复ax、bx原来的数据
   pop ax  ;
   
   ```

   
