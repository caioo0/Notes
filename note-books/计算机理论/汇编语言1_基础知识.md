# 汇编语言之基础知识

## 1、基本概念

CPU:(Central Processing Unit,中央处理单元)，cpu是一种微处理器（计算机核心部件，控制整个计算机的运作并进行运算）。

机器指令：CPU能直接识别并执行的二进制编码。

汇编指令：汇编指令是机器指令的助记符；同机器指定 一一对应。

指令：指令通常由操作码和地址码（操作数）两部分组成。

指令集：每种CPU都有自己的汇编指令集。

机器语言：机器指令的集合。

电子计算机的机器指令是一列二进制数字，计算机将之转变为一列高低电平，以使计算机的电子器件受到驱动，进行运算

每一种微处理器都有自己的机器指令集，也就是机器语言。



**汇编语言由3类指令组成：**

1. 汇编指令：机器码的助记符，有对应的机器码。
2. 伪指令：没有对应的机器码，由编译器执行，计算机不执行。
3. 其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。

汇编语言的核心是汇编指令，它决定了汇编语言的特性。
编译器：能将汇编指令转换机器指令的翻译程序每一种CPU都有自己的汇编指令集。

![image-20230629133004167](.\img\aslimg\image-20230629133004167.png)

在内存或磁盘上，指令和数据没有任何区别，都是二进制信息

![image-20230629133033677](C:\Users\Jo_ch\AppData\Roaming\Typora\typora-user-images\image-20230629133033677.png)

举个示例：
对于本文中的例子，我们都是使用GNU编译器（gcc）和汇编器(as 或者 gas)。一个快速了解汇编语言的方式就是去看编译器输出的汇编程序。使用gcc的-S选项来编译，编译器就会输出汇编而不是二进制程序。在类Unix系统上，汇编程序源文件以.s结尾。
(后缀 “s” 代表 “source” 文件, 而后缀 “a”表示 “archive” (library) 文件.) 所以, `gcc -S main.c` :

```c
#include <stdio.h>

int main( int argc, char *argv[] )
{
    printf("hello %s\n","world");
    return 0;
}
```
会生成 main.S，如下：
```
choi@choi:~/gcc$ cat main.s
        .file   "main.c"
        .text
        .section        .rodata
.LC0:
        .string "world"
.LC1:
        .string "hello %s\n"
        .text
        .globl  main
        .type   main, @function
main:
.LFB0:
        .cfi_startproc
        endbr64
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
        subq    $16, %rsp
        movl    %edi, -4(%rbp)
        movq    %rsi, -16(%rbp)
        leaq    .LC0(%rip), %rsi
        leaq    .LC1(%rip), %rdi
        movl    $0, %eax
        call    printf@PLT
        movl    $0, %eax
        leave
        .cfi_def_cfa 7, 8
        ret
        .cfi_endproc
.LFE0:
        .size   main, .-main
        .ident  "GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0"
        .section        .note.GNU-stack,"",@progbits
        .section        .note.gnu.property,"a"
        .align 8
        .long    1f - 0f
        .long    4f - 1f
        .long    5
0:
        .string  "GNU"
1:
        .align 8
        .long    0xc0000002
        .long    3f - 2f
2:
        .long    0x3
3:
        .align 8
4:
```
注意汇编程序由三个不同的元素组成：

- 指示（Directives） 以点号开始，用来指示对编译器，连接器，调试器有用的结构信息。指示本身不是汇编指令。例如，.file 只是记录原始源文件名。.data表示数据段(section)的开始地址, 而 .text 表示实际程序代码的起始。.string 表示数据段中的字符串常量。 .globl main指明标签main是一个可以在其它模块的代码中被访问的全局符号 。至于其它的指示你可以忽略。
- 标签（Labels） 以冒号结尾，用来把标签名和标签出现的位置关联起来。例如，标签.LC0:表示紧接着的字符串的名称是 .LC0. 标签main:表示指令 pushq %rbp是main函数的第一个指令。按照惯例， 以点号开始的标签都是编译器生成的临时局部标签，其它标签则是用户可见的函数和全局变量名称。
- 指令（Instructions） 实际的汇编代码 (pushq %rbp), 一般都会缩进，以便和指示及标签区分开来。

运行`gcc`可以把这个汇编代码转换为可执行程序。gcc会推断出它是汇编程序，对它进行汇编并和标准库链接在一起:
```
choi@choi:~/gcc$ cat main.c
#include <stdio.h>

int main( int argc, char *argv[] )
{
    printf("hello %s\n","world");
    return 0;
}
choi@choi:~/gcc$ gcc main.s -o main
choi@choi:~/gcc$ ./main
hello world
```
> 小贴士: AT&T 语法和 Intel 语法
> 
> 注意GNU工具使用传统的AT&T语法。类Unix操作系统上，AT&T语法被用在各种处理器上。Intel语法则一般用在DOS和Windows系统上。下面是AT&T语法的指令：
movl %esp, %ebp
movl是指令名称。%则表明esp和ebp是寄存器.在AT&T语法中, 第一个是源操作数,第二个是目的操作数。
在其他地方，例如interl手册，你会看到是没有%的intel语法, 它的操作数顺序刚好相反。下面是Intel语法:
MOVQ EBP, ESP
当在网页上阅读手册的时候，你可以根据是否有%来确定是AT&T 还是 Intel 语法。
> 
## 2、存储器



随机存储器（RAM）在程序的执行过程中可读可写，必须带电存储。

只读存储器（ROM）在程序的执行过程中只读，关机数据不丢失。

![image-20230628160846430](.\img\aslimg\image-20230628160846430.png)

![image-20230628162534665](.\img\aslimg\image-20230628162534665.png)

![image-20230628163328506](.\img\aslimg\image-20230628163328506.png)

## 3、总线

### 1、总线

总线是连接各个部件的信息传输线，是`各个部件共享的传输介质`。

主板上有核心器件和一些主要器件，这些器件通过总线（地址总线、数据总线、控制总线）相连。这些器件有**CPU、存储器、外围芯片组、扩展插槽**等。扩展插槽上一般插有RAM内存条和各类接口卡。

![image-20230628165738778](C:\Users\Jo_ch\AppData\Roaming\Typora\typora-user-images\image-20230628165738778.png)

总线根据位置分类：

- 片内总线（芯片内部总线）
- 系统总线（计算机各部件之间的信息传输线）

根据传送信息的不同，系统总线从逻辑上又分为3类：

- 地址总线
- 控制总线
- 数据总线。

CPU要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行以下3类信息的交互。

**地址总线**：CPU通过地址总线来指定存储单元

![image-20230628170243317](.\img\aslimg\image-20230628170243317.png)



1根导线可以传送的稳定状态只有两种，高电平或是低电平。用二进制表示就是1或0

上图所示有10根地址线即一次可以传输10位，访问存储单元地址为1011，寻址范围为0 ~ (210 - 1)

**数据总线**：CPU与内存或其他器件之间的数据传送是通过数据总线来进行的

![image-20230628170520346](.\img\aslimg\image-20230628170520346.png)

8根数据线一次可传送一个8位二进制数据（即一个字节），传送2个字节需要两次；16根数据线一次可传送2个字节（内存对齐核心原理）

**控制总线**：CPU对外部器件的控制是通过控制总线来进行的。

有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU对外部器件的控制能力。

### 2、CPU对存储器的读写

![image-20230628171224909](.\img\aslimg\image-20230628171224909.png)

1. cpu通过地址线将地址信息3发出
2. PU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。
3. 存储器将3号单元中的数据8通过数据线送入CPU。写操作与读操作的步骤相似。
   联想：在组成原理中用微操作表示：(PC) → MAR; 1 → R; M(MAR) → MDR; …

3、CPU对外设的控制
CPU对外设都不能直接控制，如显示器、音箱、打印机等。

直接控制这些设备进行工作的是插在扩展插槽上的接口卡。

扩展插槽通过总线和CPU相连，所以接口卡也通过总线同CPU相连。CPU可以直接控制这些接口卡，从而实现CPU对外设的间接控制。

如：CPU无法直接控制显示器，但CPU可以直接控制显卡，从而实现对显示器的间接控制


## 4、内存地址空间

CPU将系统中各类存储器看作一个逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。
对于CPU，所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力限制。(或许就是计组中学的统一编址吧)

![image-20230628171555289](.\img\aslimg\image-20230628171555289.png)

每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据（对ROM写无效）。

![image-20230628171625717](.\img\aslimg\image-20230628171625717.png)

## 5. 课后检测点

```
# 问题
1个CPU的寻址能力为8KB，那么它的地址总线的宽度为13

1KB的存储器有 1024 个存储单元，存储单元的编号从 0 到 1023

1KB的存储器可以存储 1024*8=2^13=8192 个bit， 1024个Byte

1GB是 1024^3 个Byte,1MB是 1024^2个Byte、1KB是 1024个Byte

8080、8088、80296、80386的地址总线宽度分别为16根、20根、24根、32根，则它们的寻址能力分别为: 2^6=64 （KB）、 2^0=1 （MB）、 2^4=16 （MB）、2^2=4（GB）

8080、8088、8086、80286、80386的数据总线宽度分别为8根、8根、16根、16根、32根。则它们一次可以传送的数据为: 1 （B）、 1 （B）、 2 （B）、 2 （B）、 4 （B）

从内存中读取1024字节的数据，8086至少要读 512 次，80386至少要读 256 次

在存储器中，数据和程序以 01(二进制) 形式存放

# 解释
因为1kb=1024B,1B=8bit,所以总的bit就是1024*8bit,即2^13
一个存储器单元能存放1Byte,即1字节的数据,1kb即1024b,所以为1024个单元
存储器每个存储单元可以存放1Byte,那么1Byte即8bit,所以转换一下,可以得到1024*8和1024的结果
1B=1024bit,1M=1024B,1G=1024M,相互换算得到
一根线可以可以有两个表示状态,16根可以换算成216种状态,既然是KB,那么除以210即可后面几个同理,就是换算单位需要注意
8根可以一次传输1Byte,所以前两个空就是1,16/8=2,所以后面是2,最后32/8=4
根据题6的结果回答,1024Byte/2Byte是512,后面也是1024/4=256
这个没什么好说的了,都是01二进制的形式
```





## 6. 资料

1. 参考：https://blog.csdn.net/qq_39654127/article/details/88698911
2. 监测点答案：https://blog.csdn.net/Dueser/article/details/120970387