# 原生类型

Rust 提供了多种原生类型（`primitives`），包括：

## 标量类型（scalar type）

- 有符号整数（signed integers）：`i8`、`i16`、`i32`、`i64`、`i128` 和 `isize`（指针宽度） 

- 无符号整数（unsigned integers）： `u8`、`u16`、`u32`、`u64`、`u128` 和 `usize`（指针宽度）

- 浮点数（floating point）： `f32`、`f64`

- `char`（字符）：单个 Unicode 字符，如 `'a'`，`'α'` 和 `'∞'`（每个都是 4 字节）

- `bool`（布尔型）：只能是 `true` 或 `false`

- 单元类型（unit type）：`()`。其唯一可能的值就是 `()` 这个空元组

尽管单元类型的值是个元组，它却并不被认为是复合类型，因为并不包含多个值。

## 复合类型（compound type）

- 数组（array）：如 `[1, 2, 3]`
- 元组（tuple）：如 `(1, true)`

变量都能够显式地给出**类型说明**（type annotation）。数字还可以通过**后缀**（suffix）或**默认方式**来声明类型。整型默认为 `i32` 类型，浮点型默认为 `f64`类型。注意 Rust 还可以根据上下文来推断（infer）类型（译注：比如一个未声明类型整数和 `i64` 的整数相加，则该整数会自动推断为 `i64` 类型。仅当根据环境无法推断时，才按默认方式取整型数值为 `i32`，浮点数值为 `f64`）。



```rust
    println!("0011 AND 0101 is {:04b}", 0b0011u32 & 0b0101);
    println!("0011 OR 0101 is {:04b}", 0b0011u32 | 0b0101);
    println!("0011 XOR 0101 is {:04b}", 0b0011u32 ^ 0b0101);
    println!("1 << 5 is {}", 1u32 << 5);
    println!("0x80 >> 2 is 0x{:x}", 0x80u32 >> 2);
    /*
    0011 AND 0101 is 0001
    0011 OR 0101 is 0111
    0011 XOR 0101 is 0110
    1 << 5 is 32
    0x80 >> 2 is 0x20
    */
```

![image-20230626225638163](.\img\image-20230626225638163.png)

## 十六进制转换

十六进制（英文名称：Hexadecimal），是计算机中数据的一种表示方法。同我们日常生活中的表示法不一样。它由0-9，A-F组成.与10进制的对应关系是：0-9对应0-9；A-F对应10-15；

```mathematica
比如：
012A=0 X 163 + 1 X 162+ 2 X 161 + 10 X 160 = 298
其中：
a=10 b=11 c=12 d=13 e=14 f=15

1A转为二进制：0001 1010 
0001 1010 再通过二进制的算法转十进制：0001 1010=1 X 24 + 1 X 23 + 1 X 21 = 26

```

