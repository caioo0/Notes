**第11章 网络编程**

本章为网络编程相关内容，建议用《TCP/IP 网络编程》及《Linux高性能服务器编程》等代替。

**11.1 客户端-服务器编程模型**

网络应用都是基于**客户端-服务器模型**的。采用此模型，一个应用是由**一个服务器进程和一个或多个客户端进程**组成的。

服务器管理某种资源，并通过操作这种资源来为它的客户端提供服务。

客户端-服务器模型中的基本操作是**事务**。一个客户端-服务器事务包括以下四步：

1. 客户端需要服务时，向服务器发送一个请求，发起一个事务。比如客户端请求下载某个文件。
2. 服务器收到请求后，解释它并以适当方式操作自己的资源。比如服务器从磁盘读客户端所请求的文件。
3. 服务器给客户端发送一个响应，并等待下一个请求。比如将客户端请求的文件发送给客户端。
4. 客户端收到响应并处理它。比如客户端下载收到的文件。

注意客户端和服务器都是**进程**，两者可以在一台主机上也可以在不同的主机上。

**11.2 网络**

对主机而言，**网络是一种 I/O 设备**，是**数据源和数据接收方**。

一个插到 I/O 总线扩展槽的**网络适配器**提供了到网络的物理接口。从网络接收到的数据从适配器经过 I/O 和内存总线复制到内存，通常是 **DMA 传送**。

网络的最底层是 **LAN（局域网）**，以太网是最流行的局域网技术。

在一个以太网中，多台主机通过电缆连接到一个**集线器**上。

多个以太网可以通过**网桥**连接起来构成一个**桥接以太网**。

​    ![0](https://note.youdao.com/yws/public/resource/9d4a7967bd864a75eac689866aa19533/xmlnote/17FE9986BBAF4098ADA3100D40BE8775/39135)

网络的重要特性：它能由采用完全不同和不兼容技术的各种局域网和广域网组成。

网络协议要具备的两个基本能力：

1. **命名机制**：提供一种一致的主机地址格式来表示主机地址。
2. **传送机制**：定义了统一格式的协议数据单元来传送数据。

**从客户端 A 发送数据到服务器端 B 的基本步骤**

1. 主机 A 上的**客户端**进行一个**系统调用**，从客户端的虚拟地址空间复制数据到内核缓冲区中。
2. 主机 A 上的**协议软件**通过在数据前**附加互联网络包头和 LAN1 帧头**，创建了一个 LAN1 的帧，然后传送此帧到适配器。其中 LAN1 帧头寻址到路由器（理解：这应该是指链路层分组的首部），互联网络包头寻址到主机 B（理解：这应该指网络层 IP 数据报的首部）。
3. LAN1 适配器把该帧复制到网络上。
4. 此帧到达路由器时，**路由器的 LAN1 适配器**从电缆上读取它，并把它传送到**协议软件**。
5. 路由器从互联网络包头中**提取出目的互联网络地址，并用它作为路由表的索引，确定向哪里转发这个包**（本例中为 LAN2），路由器剥落掉旧的 LAN1 帧头，加上寻址到主机 B 的 LAN2 帧头，并把得到的帧传送到适配器。
6. 路由器的 LAN2 适配器复制该帧到网络上。
7. 此帧到达主机 B 时，它的**适配器**从电缆上读到此帧，并将它传送到**协议软件**。
8. 主机 B 上的**协议软件**剥落掉包头和帧头。当**服务器**进行一个读取这些数据的**系统调用**时，协议软件最终将得到的数据复制到服务器的虚拟地址空间。

​    ![0](https://note.youdao.com/yws/public/resource/9d4a7967bd864a75eac689866aa19533/xmlnote/7E58F36656214EDA9823F4400116EF44/39185)

**总结**：以上 8 个步骤可以分为**两部分：数据在主机上通过系统调用在进程的虚拟地址空间与内核间传送，数据在网络间传送。**

**11.3 全球IP因特网**

全球 IP 因特网即互联网。

互联网中的每台主机都有实现 TCP/IP 协议的软件。

互联网中的客户端和服务器混合使用**套接字接口函数**和 **Unix I/O 函数**来进行通信。通常将**套接字函数实现为系统调用**，这些系统调用会陷入内核，并调用各种**内核模式的 TCP/IP 函数**。

​    ![0](https://note.youdao.com/yws/public/resource/9d4a7967bd864a75eac689866aa19533/xmlnote/2FDE10DACC3D42F384A83E602F38E092/39194)

**11.3.1 IP地址**

一个 IP 地址就是一个 **32 位无符号整数**。网络程序将 IP 地址存放在下面的 **IP 地址结构**中。

​                struct in_addr {    uint32_t s_addr; } // 以网络字节顺序（大端法）存储，即使主机字节顺序是小端法。              

**TCP/IP 定义的统一的网络字节顺序为大端字节顺序**。Unix 提供了几个函数来在网络和主机字节顺序间实现转换

现在的 intel 系统主要都是小端序。

​                \#include <arpa/inet.h> uint32_t htonl(uint32_t hostlong);   //返回网络字节顺序 uint16_t htons(uint16_t hostshort);  //返回网络字节顺序 uint32_t ntohl(uint32_t netlong);   //返回按照主机字节顺序的值 uint16_t ntohs(uint16_t netshort);  //返回按照主机字节顺序的值              

**二进制IP地址与点分十进制串之间的转换**

​                \#include <arpa/inet.h> int inet_pton(AF_INET, const char *src, void *dst); //将点分十进制转换为二进制的网络字节顺序的 IP 地址。成功则返回 1，如果 src 为非法地址则返回 0，出错返回 -1。 const char *inet_ntop(AF_INET, const void*src, char *dst, socklen_t size); //将二进制网络字节顺序的 IP 地址转换为点分十进制，并把得到的字符串最多 size 个字节复制到 dst。     //如果成功返回点分十进制串的指针，若出错返回 NULL。              

**11.3.2 因特网域名**

域名到 IP 地址之间的映射通过分布在世界各地的数据库来维护。

DNS 数据库包含上百万条主机条目结构，每一条定义了一组域名和一组 IP 地址之间的映射。

每台主机都有**本地定义的域名 localhost**，这个域名总是映射为**回送地址 127.0.0.1**。

​                linux>>nslookup localhost  // 查看域名 localhost 的地址 Address:127.0.0.1 linux>>hostname            // 查看本机的域名              

如 http://localhost:7474/browser/ 和 127.0.0.1:7474/browser/ 都会打开 neo4j 的窗口。

多个域名可以映射到同一个 IP 地址，最常见的情况是多个域名映射到同一组的多个 IP 地址。

**11.3.3 因特网连接**

客户端和服务器通过在连接上接收和发送字节流来通信。连接是点对点的与全双工的。

连接的端点是**套接字**，套接字地址由一个 IP 地址和一个 16 位的端口号组成。用 “地址：端口” 来表示。

客户端套接字地址中的端口是由内核自动分配的**临时端口**，服务器套接字地址中的端口通常是某个**熟知端口**。

Web 服务器常用端口 **80**，熟知名字为 http；邮件服务器使用端口 80，熟知名字为 smtp。

文件 **/etc/services** 中包含一张主机提供的熟知端口与熟知名字之间的映射。

一个连接由两端的套接字地址唯一确定。

​    ![0](https://note.youdao.com/yws/public/resource/9d4a7967bd864a75eac689866aa19533/xmlnote/E19E01C749984A59874AB2CB7BAC191A/51783)

**11.4 套接字接口**

套接字接口是一组函数，和 Unix I/O 函数结合起来创建网络应用。

​    ![0](https://note.youdao.com/yws/public/resource/9d4a7967bd864a75eac689866aa19533/xmlnote/4AC96871FA3F472298C84F6135755F04/51787)

**11.4.1 套接字地址结构**

从内核角度看，套接字是通信的端点；从程序的角度看，套接字是一个有相应描述符的打开文件。

套接字地址存放在 **sockaddr_in** 结构中。

​                '互联网套接字地址结构' struct sockaddr_in {    uint16_t        sin_family;  // 协议族    uint16_t        sin_port;    // 网络字节顺序的端口号    struct in_addr  sin_addr;    // 网络字节顺序的 IP 地址    unsigned char   sin_zero[8]; } '通用套接字地址结构' struct sockaddr {    uint16_t  sa_family;    // 协议族    char      sa_data[14];  // 地址 }              

connect, bind, accept 函数都接受一个指向通用 sockaddr 结构的指针，然后要求应用程序将于协议特定结构相关的指针强制转换成这个通用结构。

**11.4.2 socket函数**

客户端和服务器都使用 socket 函数来创建一个套接字描述符。

​                \#include<sys/types.h> #include<sys/socket.h> int socket(int domain, int type, int protocol);  // 如果成功返回描述符，出错返回 -1              

**socket 函数的使用**

可以通过如下方式使套接字成为连接的一个端点。但最好使用 **getaddrinfo 函数**来自动生成这些参数，这样可以让代码与协议无关。

​                clientfd = socket(AF_INET, SOCK_STREAM, 0);  // AF_INET 表示使用 32 位 IP 地址， SOCK_STREAM 表示这个套接字是连接的一个端点。              

socket 返回的 clientfd 描述符仅是部分打开的，还不能用于读写。如何完成打开套接字的工作，取决于是客户端还是服务器。

**11.4.3 connect函数**

客户端通过调用 connect 函数来建立和服务器的连接。

​                \#include <sys/socket.h> int connect(int clientfd, const struct sockaddr* addr, socklen_t addrlen); // 若成功返回 0，若出错返回 -1。              

connect 函数会阻塞，一直到连接成功建立或发生错误。

**11.4.4 bind函数**

bind, listen 和 accept 函数都是服务器端用的函数。

bind 函数用来将套接字描述符和套接字地址关联起来。

​                \#include <sys/socket.h> int bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen); // 若成功返回 0，若出错返回 -1。              

**11.4.5 listen函数**

listen 函数将套接字转换为监听状态。

​                \#include <sys/socket.h> int listen(int sockfd, int backlog) // 若成功返回 0，若出错返回 -1。              

参数 backlog 通常会设置为一个较大的值，如 1024。

**11.4.6 accept函数**

accept 函数用来接受来自客户端的连接请求。

​                \#include <sys/socket.h> int accept(int listenfd, struct sockaddr* addr, int* addrlen); // 若成功返回已连接描述符，若出错返回 -1。              

**11.4.7 主机和服务的转换**

**11.4.8 套接字接口的辅助函数**

**11.4.9 echo客户端和服务器的示例**

**11.5  Web服务器**

**11.5.1  Web基础**

**11.5.2  Web内容**

**11.5.3  HTTP事务**

**11.5.4 服务动态内容**

**11.6 综合: TINY Web服务器**