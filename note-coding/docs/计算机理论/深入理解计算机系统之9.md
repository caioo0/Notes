**第9章 虚拟内存**

虚拟内存为每个进程提供了一个大的、一致的和私有的地址空间。

虚拟内存提供了三个重要能力：

1. 将主存看成一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存中传送数据。
2. 为每个进程提供了一致的地址空间，简化了内存管理。进而简化了链接、进程间共享数据、进程的内存分配、程序加载。
3. 保护了每个进程的地址空间不被其他进程破坏。

虚拟内存的几个特点：

1. 虚拟内存遍及计算机系统的所有层面，在硬件异常、汇编器、链接器、加载器、共享对象、文件和进程的设计中都扮演着重要角色。
2. 虚拟内存给予应用程序强大的能力，可以创建和销毁内存片（chunk），将内存片映射到磁盘文件的某个部分，以及与其他进程共享内存。
3. 虚拟内存很危险。每次应用程序引用一个变量、间接引用一个指针或调用一个如 malloc 的动态分配程序时，都会和虚拟内存交互，如果使用不当就会发生错误。

**9.1 物理和虚拟寻址**

主存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的**物理地址**。CPU 访问内存最自然的方式就是使用物理地址，称为**物理寻址**。

现代 CPU 使用的是**虚拟寻址**：CPU 通过生成一个**虚拟地址（VA）**来访问主存，这个虚拟地址首先通过地址翻译转换为物理地址。

地址翻译需要 CPU 硬件和操作系统之间的紧密合作。CPU 芯片上名为内存管理单元（MMU）的专用硬件利用存放在主存中的**查询表**来**动态翻译虚拟地址**。

**9.2 地址空间**

地址空间是一个非负整数地址的有序集合：{0, 1, 2, ...}

如果地址空间中的整数是连续的，就称为线性地址空间。

在计算机系统中，CPU 从一个有 N=2^n 个地址的地址空间中生成虚拟地址空间。

一个地址空间的大小是由表示地址的位数来描述的，例如现代的 64 位计算机一般支持 64 位虚拟地址空间。

**主存中的每个字节**都有一个虚拟地址和一个物理地址。

**9.3 虚拟内存作为缓存的工具**

虚拟内存作为磁盘的高速缓存，和存储器层次结构中的其他缓存一样，磁盘（较低层）中的数据被分割成块，作为磁盘和主存（较高层）之间的传输单元。

VM（虚拟内存）系统通过将虚拟内存分割为**虚拟页**（Virtual Page，**VP**）来处理此问题。每个虚拟页的大小为 P=2^p。

类似的，物理内存被分割为**物理页**（PP），大小也是 P 字节。物理页也被称为**页帧**。

任何时刻，所有的虚拟页都被分为了**三个不相交的子集：**

1. **未分配的**：VM 系统还未分配（未创建）的页。未分配的块没有任何数据与它们相关联，因此不占用任何磁盘空间。
2. **已缓存的**：当前已缓存在物理内存中的已分配页。
3. **未缓存的**：未缓存在物理内存中的已分配页。

​    ![0](https://note.youdao.com/yws/public/resource/571afc0df48bcc5faedf009f92ea125d/xmlnote/E1A3E07FE676441E9E7024CCCFF80E7F/50823)

**9.3.1 DRAM缓存的组织结构**

主存一般采用 DRAM，DRAM 与磁盘之间的速度差要比 SRAM 与 DRAM 之间的速度差大很多，并且从磁盘的一个扇区读取第一个字节的时间开销比读这个扇区中的连续字节要慢很多。因此 DRAM 缓存的组织结构与高速缓存有很大不同。

因为**严重的不命中处罚**和**访问第一个字节的开销**，虚拟页一般很大，**通常在 4KB~2MB**，且 DRAM 缓存是**全相联的**，即**任何虚拟页都可以放在任何的物理页中**。不命中时的替换策略也很重要。

因为访问磁盘很慢，所以 DRAM 都采用**写回（即延时写）**，而非直写。

**9.3.2 页表**

VM 系统需要判定一个虚拟页是否缓存在 DRAM 中的某个地方，如果是需要确定虚拟页存放在哪个物理页中，如果不是需要判断虚拟页存放在磁盘的哪个位置；在 DRAM 中选择一个牺牲页并把虚拟页从磁盘复制到 DRAM 中替换这个牺牲页。

这些功能由操作系统软件、MMU 中的地址翻译硬件、页表共同完成：

1. **页表**是一个存放在 DRAM 中的数据结构，它**将虚拟页映射到物理页**。
2. 每次地址翻译硬件将一个虚拟地址转换为硬件地址时都会读取页表。
3. 操作系统负责维护页表的内容，以及在磁盘和 DRAM 间传送页。

页表是一个**页表条目（PTE）**构成的**数组**，虚拟地址空间中的每个页在页表中的一个固定偏移量处都有一个 PTE。可以认为 PTE 由**一个有效位**和**一个 n 位地址字段**组成。有效位表明该虚拟页是否被缓存在 DRAM 中。

对于三种不同的页，其页表条目的内容不同：

1. 已缓存的页：有效位=1，n 位地址字段表示该页**在 DRAM 中相应的物理页**的起始地址。
2. 未缓存的页：有效位=0，n 位地址字段表示**该虚拟页在磁盘上的起始地址**。
3. 未分配的页：有效位=0，地址字段为空。

​    ![0](https://note.youdao.com/yws/public/resource/571afc0df48bcc5faedf009f92ea125d/xmlnote/FBD0D971765E461CA6CC19E462DF4CFD/50864)

**9.3.3 页命中**

例如当 CPU 要读取上图中的 VP2 就会发生页命中。

地址翻译硬件使用虚拟地址作为索引**从页表中查找相应的页表条目**，然后读取条目中的内容来获取该虚拟页在 DRAM 中的物理地址。

**9.3.4 缺页**

DRAM 缓存不命中称为**缺页**。如 CPU 要读取上图中的 VP3 时，会从页表条目的有效位发现该页没有被缓存。

当发生缺页会触发一个**缺页异常**。缺页异常会调用内核中的**缺页异常处理程序**，该程序会**从已缓存的页中选择一个牺牲页**。**如果该牺牲页之前已经被修改，内核会先将它复制回磁盘（即写回）**，然后内核会占用它的物理页并修改它的页表条目为未缓存的。

缺页异常处理完成后，会重新启动导致缺页的指令，该指令重新进行对该虚拟地址的操作。

**9.3.5 分配页面**

初始的虚拟地址空间中的虚拟页基本都是未分配的，当调用了 malloc 就会分配一个或一些新的虚拟页，这些页指向磁盘上的对应页面。

理解：或许是因为 malloc 只负责分配内存，不负责创建对象，所以 malloc 分配得到的页是未缓存的。

​    ![0](https://note.youdao.com/yws/public/resource/571afc0df48bcc5faedf009f92ea125d/xmlnote/FA3808AE05DF4374B6770AC830083026/50899)

**9.3.6 又是局部性救了我们**

虚拟内存利用了局部性。

通过将活动页面集合（称为**工作集**）缓存到 DRAM 中来减少出现缺页的情况。

如果工作集的大小超出了 DRAM 的大小，程序将会发生**抖动**，页面会不断地换进换出。

根据本节内容可以区分主存缓存与各高速缓存的组织结构的不同之处：

1. 高速缓存将地址位划分为有效位、标记位、组索引位、块偏移位，通过组选择、行匹配、字抽取来完成对数据的操作。
2. 主存采用了 VM 系统，使用页表来实现对数据的查找。

**9.4 虚拟内存作为内存管理的工具**

实际上每个进程都会有一个独立的虚拟地址空间，也都有一个独立的页表。不同进程的虚拟页面可能映射到同一个物理页面上。

通过按需页面调度与独立的虚拟地址空间，VM 在内存管理时实现了以下功能：

1. 简化链接。独立的地址空间允许为每个进程的内存映像使用相同的基本格式，如代码段都是从 0x400000 开始，数据段都在代码段后，栈从用户进程地址空间最高的地方向下生长等。因为采用了虚拟地址，所以这些可执行文件是独立于物理内存中代码和数据的最终位置的。

2. 简化加载。当要向内存中加载可执行文件和共享对象文件时，Linux 加载器为代码段和数据段分配虚拟页并将其标记为无效的（即未缓存的），将页表条目指向目标文件中适当的位置即可。

3. 1. 将一组连续的虚拟页映射到任意一个文件中的任意一个位置叫做**内存映射**。

4. 简化共享。独立地址空间为操作系统提供了一个管理用户进程与操作系统自身之间共享的一致机制。操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个副本，而不是在每个进程中创建单独的副本。

5. 简化内存分配。当一个进程要求分配堆空间时，操作系统分配 k 个的连续的虚拟内存页面，并将它们映射到物理内存中任意位置的 k 个任意的物理页面。由于页表工作的方式，物理页面不需要是连续的。

**9.5 虚拟内存作为内存保护的工具**

每次 CPU 生成一个虚拟地址时，地址翻译硬件都会读一个 PTE，可以通过在 PTE 上添加一些额外的许可位来控制对一个虚拟页面内容的访问。

​    ![0](https://note.youdao.com/yws/public/resource/571afc0df48bcc5faedf009f92ea125d/xmlnote/B816D8E8C5AD4C06BF9E79CC8FD04745/51004)

上图中每个 PTE 都添加了三个许可位：

1. SUP 表示进程是否必须运行在内核模式下才能访问该页。
2. READ 控制读的权限。
3. WRITE 控制写的权限。

**9.6 地址翻译**

地址翻译是通过硬件实现的。

​    ![0](https://note.youdao.com/yws/public/resource/571afc0df48bcc5faedf009f92ea125d/xmlnote/8535FB25CBB04353953A9A54D58DB9B8/51021)

地址翻译是一个 N 元素的虚拟地址空间（VAS）和一个 M 元素的物理地址空间（PAS）之间的映射。

​    ![0](https://note.youdao.com/yws/public/resource/571afc0df48bcc5faedf009f92ea125d/xmlnote/D68B42117B294AB18640DF5C0D4C7679/51026)

CPU 中有一个**页表基址寄存器**指向当前页表。

n 位的虚拟地址包含 p 位的虚拟页面偏移和 n-p 位的虚拟页号。

​    ![0](https://note.youdao.com/yws/public/resource/571afc0df48bcc5faedf009f92ea125d/xmlnote/A12700F2FF754C8AA84437C27E039634/51033)

MMU（内存管理单元） 利用**虚拟页号**来选择适当的 PTE，然后将 PTE 中的**物理页号**和虚拟地址中的**虚拟页偏移量**串联起来就得到了对应的物理地址。

页面命中时 CPU 硬件执行的步骤：

1. 处理器生成一个虚拟地址，并把它传送给 MMU。
2. MMU 根据虚拟地址生成 PTE 地址，并从主存请求得到它。
3. 主存向 MMU 返回 PTE。
4. MMU 构造物理地址，并把它传送给主存。
5. 主存返回所请求的数据字给处理器。

上述步骤可以概括为：MMU 收到处理器传来的虚拟地址后，根据虚拟地址中的虚拟页号和页表基址寄存器的内容从主存的页表中获取对应 PTE 项，根据 PTE 项中的物理页号构造出物理地址并从主存中取回数据。

页面不命中时需要通过内核的缺页异常处理程序替换页，然后重新进行一遍上述步骤。

**9.6.1 结合高速缓存和虚拟内存**

大多数系统采用物理寻址来访问 SRAM 高速缓存，即先完成了地址翻译，再根据得到的物理地址到 SRAM 高速缓存中查找。

因为访问权限的检查已经在地址翻译时完成，所以高速缓存无需处理保护问题。

问题：地址翻译要访问主存获取页表条目，相比访问高速缓存岂不是慢很多？不会的，因为页表条目也可以缓存在 SRAM 中。

**9.6.2 利用TLB加速地址翻译**

每次 CPU 产生一个虚拟地址，MMU 都要查阅一个 PTE，这带来了额外的开销。

许多系统在 MMU 中包括了一个关于 PTE 的小的缓存——**翻译后备缓冲器（TLB）**。这样所有的地址翻译步骤在 MMU 中就可以执行完成。

TLB 采用了具有较高相联度的组相联方式，用于组选择和行匹配的索引和标记字段从虚拟地址的虚拟页号中提取出来。

当 TLB 不命中时，MMU 需要从 L1 高速缓存中取出相应的 PTE 替换 TLB 中的某个已存在的条目。

**9.6.3 多级页表**

如果只用一个页表来进行地址翻译，该页表就会很大，比如一个 32 位的地址空间、4KB 的页面、4 字节的 PTE，就需要一个大小为 4MB 的页表。64 位的系统就更大了。

常用多级页表来压缩页表。

**一个两级页表的例子**

一个 32 位的地址空间中页面的大小为 4KB，则共有 1MB 个页面，可以将地址空间划分为 1024 个片，每个片包括 1024 个连续的页。

一级页表的每个 PTE 负责映射虚拟地址空间中的一个片，二级页表的每个 PTE 映射一个页。

如果某个片的 1024 个页面都没有被分配，那一级页表中这个片的 PTE 就是空的，只有该片中的页面被分配了，一级页表的 PTE 才会指向该片对应的二级页表的基址。

多级页表从两个方面降低了内存需求：

1. 如果一级页表的 PTE 是空的，那相应的二级页表根本就不存在。
2. 只有一级页表和最常用的二级页表才总是在主存中，VM 系统可以在需要时才创建、页面调入或调出二级页表。

**多级页表**

下图中虚拟地址被划分为了 k 个 VPN 和一个 VPO。每个 VPN i 都是一个到第 i 级页表的索引。

第 k 级页表中的每个 PTE 包含某个物理页面的 PPN（物理页号）或一个磁盘页的地址。其他页表中的 PTE 则包含对应的下一级页表的基址。

对于多级页表，要确定虚拟地址的物理页号，需要访问 k 个页表的 PTE。通过 TLB 将不同层次上页表的 PTE 缓存起来，但多级页表的地址翻译不比单级页表慢很多。

​    ![0](https://note.youdao.com/yws/public/resource/571afc0df48bcc5faedf009f92ea125d/xmlnote/B7C63BAFB40645068B2DE1A450FF347C/51199)

**9.6.4 综合:端到端的地址翻译**

对于一个有 TLB 和 L1 d-cache 的小系统，其：

1. 虚拟地址是 14 位。
2. 物理地址是 12 位。
3. 页面大小是 64 字节。因此对应的 VPO 和 PPO 都是 6 位，进而确定 VPN 是 8 位，PPN 是 6 位。
4. TLB 是四路组相联。因此在根据 VPN 从 TLB 中查询是否缓存了对应 PTE 时，TLB 索引字段为 2 位，标记字段为 6 位。 
5. L1 d-cache 是物理寻址、直接相联的，行大小为 4 字节，总共 16 个组。因此在根据物理地址从 L1 中查找是否缓存了对应块时，组索引为 4 位。

​    ![0](https://note.youdao.com/yws/public/resource/571afc0df48bcc5faedf009f92ea125d/xmlnote/328AC5F634D843C886E2EEC0207F95C7/51307)

以 CPU 要读地址 0x03d4 处的字节为例，端到端的地址翻译的过程如下：

1. MMU 从地址地址中抽取出 VPN（0x0F），并检查 TLB 是否有 PTE 0x0F 的副本。TLB 从 VPN 中抽取出 TLB 索引（0x03）和 TLB 标记（0x03），与 TLB 的 0x3 组中的第二个条目匹配成功，然后将缓存的 PPN（0x0D）返回给 MMU。（如果 TLB 不命中，MMU 就需要从主存取出相应的 PTE，如果发生缺页，还需要先调入合适的页面）。
2. MMU 将 PPN 和来自虚拟地址的 VPO 连接起来，形成了物理地址（0x354），然后 MMU 将物理地址发送给 L1 缓存。
3. L1 缓存从物理地址中抽取出缓存偏移 CO（0x0）、缓存组索引 CI（0x5）和缓存标记（0x0D），然后与 L1 缓存中的行进行组选择、行匹配、字抽取，这里匹配成功并读取到字节 0x36（如果匹配不成功，还需要到下级缓存继续查找）。
4. L1 缓存将字节返回给 MMU，然后 MMU j将字节传递给 CPU。

**从虚拟页号中抽取出 TLB 索引和标记字段**

​    ![0](https://note.youdao.com/yws/public/resource/571afc0df48bcc5faedf009f92ea125d/xmlnote/01309A08961A49CDBB5752AEB1EBD704/51310)

**从物理地址中抽取出标记段、组索引段、字偏移段**

​    ![0](https://note.youdao.com/yws/public/resource/571afc0df48bcc5faedf009f92ea125d/xmlnote/5D6F54D628744F47979AF49E524850C9/51312)

**9.7 案例研究: Intel Core i7/Linux内存系统**

现在的 Core i7 CPU 的实现支持 48 位（256TB）的虚拟地址空间和 52 位（4PB）的物理地址空间。还有一个兼容模式支持 32（4GB）的虚拟和物理地址空间。

**一个典型的Corei7内存系统**

CPU 中封装了 4 个核、一个所有核共享的 L3 高速缓存，一个 DDR3 内存控制器。

每个核除了包含 L1、L2 高速缓存外，还包含具有两层结构的 TLB 缓存、一组基于 QuickPath 技术的快速的点到点链路。

点到点链路是为了让一个核与其他核、外部 I/O 桥直接通信。

​    ![0](https://note.youdao.com/yws/public/resource/571afc0df48bcc5faedf009f92ea125d/xmlnote/85B7D5BC17974997AE4E4CCE08C94F3A/51463)

**实验室电脑的 CPU 硬件情况（鲁大师检测）**

- 处理器：英特尔 Core i7-6700K @ 4.00GHz 四核
- 速度：4.01 GHz (100 MHz x 40.0)
- 处理器数量：核心数: 4 / 线程数: 8
- 核心代号：Skylake
- 生产工艺 ：14 纳米
- 插槽/插座：Socket LGA1151
- 一级数据缓存：4 x 32 KB, 8-Way, 64 byte lines
- 一级代码缓存：4 x 32 KB, 8-Way, 64 byte lines
- 二级缓存：4 x 256 KB, 4-Way, 64 byte lines
- 三级缓存：8 MB, 16-Way, 64 byte lines
- 特征：MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, HTT, EM64T, EIST, Turbo Boost

主存：ChannelA-DIMM0	三星 DDR4 2400MHz 8GB

**9.7.1 Core i7地址翻译**

Core i7 采用了四级页表结构，每个进程有它自己私有的页表层次结构。

当一个 Linux 进程运行时，与已分配的页相关联的页表都是驻留在内存中的。

CR3 控制寄存器指向第一级页表的起始位置。CR3 的值是每个进程上下文的一部分，每次上下文切换时，CR3 的值都会被恢复。

**完整的Core i7地址翻译过程**

Core i7 中页的大小为 4KB，因此 VPO 与 PPO 都是 12 位，VPN 是 36 位，PPN 是 40 位。

四级页表中的每个页表都是 4KB 对齐的：页表条目的大小为 2^3 字节，每个页表包含 2^9 个页表条目，页表大小为 4KB。

​    ![0](https://note.youdao.com/yws/public/resource/571afc0df48bcc5faedf009f92ea125d/xmlnote/A7D4D55D2A444E81B04E4F53CC7FDBFB/51491)

**一、二、三级页表的条目格式**

因为页表都是 4KB 对齐的，所以页表物理地址 52 位中的低 12 位不需要保存，PTE 中只保存了下级页表物理基地址的高 40 位。

​    ![0](https://note.youdao.com/yws/public/resource/571afc0df48bcc5faedf009f92ea125d/xmlnote/894CE7B77FD349D5BAD8B90FAB3C097A/51522)

**四级页表的条目格式**

​    ![0](https://note.youdao.com/yws/public/resource/571afc0df48bcc5faedf009f92ea125d/xmlnote/87B702CC60C94A17A4D271354DE22BD4/51533)

PTE 有三个权限位，控制对页的访问。R/W 控制是只读还是读写；U/S 控制用户模式是否可以访问；XD 用来禁止从某些页读指令。

每次访问一个页，MMU 都会设置 A 位，称为引用位。内核可以利用这个引用位实现它的页替换算法。

每次写了一个页后，MMU 都会设置 D 位，称为修改位。修改位告诉内核在替换该页前是否必须写回牺牲页。

内核可以通过调用一条特殊的内核模式指令来清除引用位或修改位。

**四级页表将虚拟地址翻译为物理地址的过程**

36 位 VPN 划分为 4 个 9 位的片，每个片用作某一级页表查询时的偏移量。

​    ![0](https://note.youdao.com/yws/public/resource/571afc0df48bcc5faedf009f92ea125d/xmlnote/93B94341B5ED449FA0FED693ABF8A626/51553)

**9.7.2 Linux虚拟内存系统**

内核虚拟内存包含内核中的代码和数据结构，内核虚拟内存的某些区域被映射到所有进程共享的物理页面，例如内核代码和全局数据结构。

内核虚拟内存的其他区域包含每个进程都不相同的数据，比如页表、内核在进程的上下文执行代码时使用的栈等。

​    ![0](https://note.youdao.com/yws/public/resource/571afc0df48bcc5faedf009f92ea125d/xmlnote/0743116E153A4AC487CD06CE31DCA005/51561)

**Linux虚拟内存区域**

Linux 将虚拟内存组织成一些区域（也叫做段）的集合。一个区域就是已分配的虚拟内存的连续片，例如代码段、数据段、堆、共享库段、用户栈等多是不同的区域。

每个已分配的虚拟页面都保存在某个区域中。不同区域间可以有间隙。

下图是一个进程中虚拟内存区域的内核数据结构。内核为每个进程维护一个单独的任务结构（task_struct），包含了内核运行该进程所需的所有信息。

task_struct 中有一个条目指向 mm_struct，它描述了虚拟内存的当前状态。

mm_struct 中的 pgd 字段指向第一级页表的基址，当内核运行这个进程时，就把 pgd 放到 CR3 控制寄存器中。

mm_struct 中的 mmap 指向一个 vm_area_struct（区域结构）的链表，每个区域结构都描述了当前虚拟地址空间的一个区域。

一个区域结构包含以下字段：

1. vm_start：指向区域起始处；
2. vm_end：指向区域结束处；
3. vm_prot：描述区域内包含的所有页的读写许可权限；
4. vm_flags：描述区域内的页面是私有的，还是与其他进程共享的；
5. vm_next：指向链表中下一个区域结构。

​    ![0](https://note.youdao.com/yws/public/resource/571afc0df48bcc5faedf009f92ea125d/xmlnote/03B09AF46C0248F7855DE378D0B11557/51584)

**Linux缺页异常处理程序**

当触发缺页后，缺页处理程序会执行以下步骤：

1. 判断虚拟地址 A 是否合法：将 A 和每个区域结构中的 vm_start 和 vm_end 相比较。如果不合法会触发一个段错误。
2. 判断试图进行的内存访问是否合法：检查进程是否有读、写、执行此区域内页面的权限。如果不合法会触发一个保护异常。
3. 选择牺牲页面并进行替换，如果牺牲页面被修改过需要先写回。

**9.8 内存映射**

内存映射：Linux 通过将一个虚拟内存区域与一个磁盘上的对象关联起来，来初始化这个虚拟内存区域的内容。

虚拟内存区域可以映射到两种类型的对象：

1. Linux 文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分，如一个可执行目标文件。如果区域比文件区要大，就用 0 填充剩下的部分。
2. 匿名文件：一个区域可以映射到一个匿名文件，匿名文件由内核创建，包含的全是二进制零。

无论哪种情况，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换文件（也叫交换空间）之间换来换去。

交换空间的大小限制着当前运行着的进程能够分配的虚拟页面的综述。

**9.8.1 再看共享对象**

**9.8.2 再看fork函数目** 

**9.8.3 再看execve函数**

 **9.8.4 使用mmap函数的用户级内存映射**

**9.9 动态内存分配**

**9.9.1 malloc和free函数**

**9.0.2 为什么要使用动态内存分配**

**9.9.3 分配器的要求和目标**

**9.9.4 碎片**

**9.9.5 实现问题**

**9.9.6 隐式空闲链表**

**9.9.7 放置已分配的块**

**9.9.8 分割空闲块**

**9.9.9 获取额外的内存** 

**9.9.10 合并空闲块**

**9.9.11 带边界标记的合并**

**9.9.12 综合:实现一个简单的分配器**

**9.9.13 显式空闲链表**

**9.9.14 分离的空闲链表**

**9.10 垃圾收集**

**9.10.1 垃圾收集器的基本知识**

**9.10.2 Marke.Swee垃圾收集器**

**9.10.3 c程序的保守Mark&Sweep**

**9.11 c程序中常见的与内存有关的错误**

与内存有关的错误经常在时间上和空间上距离错误源一段距离后才表现出来。

注意：以下错误都是 C 程序中的常见错误，不完全适用于 C++ 程序。

**9.11.1 间接引用坏指针**

虚拟地址空间中有一些大洞（即区域之间的部分），当试图间接引用一个指向这些洞的指针就会触发段异常。

试图写一些只读的区域会触发保护异常。

**经典的scanf错误**

​                scanf("%d", val); //经典的 scanf 错误：试图将一个字写到 val 的值表示的地址处。              

如果 val 的值对应一个空洞或不能写的位置，将触发异常。如果 val 的值对应一个合法的读写位置，将会修改该处的值，通常会产生灾难性后果。

**9.11.2 读未初始化的内存**

bss 段（如未初始化的全局变量）总是被加载器初始化为 0，但是堆内存并非如此。

常见错误：假设堆内存初始化为 0。

**9.11.3 允许栈缓冲区溢出**

如果不检查输入串的大小就写到栈中的目标缓冲区就可能导致缓冲区溢出错误。

​                gets(buf);  //可能发生缓冲区溢出错误 fgets(buf); //fgets 限制了输入串的大小，避免了上述错误              

**9.11.4 其他错误**

还有其他错误如下：

1. 假设指针和它们指向的对象是相同大小的。如混淆 sizeof(int *) 和 sizeof(int)。
2. 造成错位错误。访问数组元素时越界：A[n]。
3. 引用指针,而不是它所指向的对象。如混用 *size-- 和 *(size--)。
4. 误解指针计算。如忘记指针加一的单位是指针指向的对象的大小，而不是一个字节。
5. 引用不存在的变量。如函数返回一个函数中的局部变量的地址。
6. 引用空闲堆块中的数据。如引用已经被释放了的堆中的数据。
7. 引起内存泄露。内存泄漏是缓慢、隐性的杀手，当忘记释放分配的块时会引发内存泄漏。