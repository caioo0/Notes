# 第2章:信息的表示和处理

> 《深入理解计算机系统》——简称CSAPP，被称为计算机领域的圣经
>

## 2.0 信息知识补充

现代计算机存储的信息是二进制数字 , (位 , bit) , 也就是一种二值信号

10进制数字起源于印度 , 12世纪被阿拉伯人改进, 13世纪被带到西方

对于机器来说 , 二值信号更容易表示 , 存储 ,和传输 :

- 穿孔卡片上有洞 和 无洞
- 高电压 和 低电压
- 顺时针磁场 和 逆时针磁场

将多个bit 组合在一起 , 然后给予不同含义的解释(interpretation) 就有不同的意义

比如通过二进制数字系统对正数编码 , 对字符和符号进行编码

由于bit 位是有限的 , 很难表示无穷大的数 , 一旦数字的大小超过了bit 所能表示的最大数字 , '

就会发生溢出 (overflow)

32 位int 类型的数字 , 200* 300 * 400 * 500 =12000000000

可是 32 位int 类型的数字 最大为232−1 即4294967295 , 很明显 , 溢出了

而且对于200 300 400 500 这四个数字任意进行乘法结合率和交换率 , 结果都是不变的

整数的表示只能是编码一个相对较小的数值范围, 这种表示是精确的

浮点可以编码一个较大的数值范围 , 但表示是近似的

浮点数的表示精度有限,导致了浮点的运算是不可结合的

(3.14+1e20)-1e20 =0.0

3.14+(1e20-1e20)=3.14

**C 语言的不同版本**

```bash
 gcc -std=gnu89 hello.c # GNU 89
 gcc -std=c89 hello.c #ANSI, ISO C90
 gcc -std=c99 hello.c #ISO C99
 gcc -std=c11 hello.c #ISO C11
```



**无符号**（unsigned）编码基于传统的二进制表示法，表示大于或者等于零的数字。

**补码** （two's-complement）编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。

**浮点数**（floating-point）编码是表示实数的科学记数法的以 2 为基数的版本。

计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至不能表示时，某些运算就会**溢出** （overflow）

许多安全漏洞是由算术运算的微妙细节导致的。

## 2.1 信息的存储

**字节：**计算机使用 8 位的块，作为最小的可寻址的内存单位，而不是访问内存中单独的位。

机器级程序将内存视为一个非常大的字节数组，称为**虚拟内存**（virtual memory）。

**内存地址**（address）：内存的每个字节都由一个唯一的数字来标识，称为它的，

**虚拟地址空间**（virtual address space）：所有可能内存地址的集合，实际的实现（见第 9 章）是将动态随机访问存储器（DRAM）、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。 

**程序对象**（ program object） : 程序数据 , 指令和控制信息

C 语言中的指针的值 就是它指向对象(整数 , 结构体 ,程序对象)的存储块的第一个字节的虚拟地址

尽管C 编译器将指针的值 和 所指向对象的数据类型联系了起来 , 但实际上 , **机器级程序不包含数据类型的信息**

```
 int a;
 int* p=&a;
```

一个程序对象：一个字节块

程序本身：一个字节序列

指针 : 值 和 类型 , 同样是一种数据类型 , 值表示某个对象的位置 , 类型表示指向存储对象的数据类型





### 2.1.1十六进制表示法

8位二进制 : $00000000_2 ~ 11111111_2$

对应十进制 : $0_{10}~ 255_{10}$

以16 为基数 : hexadecimal (hex) (H)

' 0 '-' 9 ' 和 ' A '-' F '

对应16进制 : $00_{16} ~ FF_{16}$

![image-20230721134522173](.\img\image-20230721134522173.png)



十六进制以 0x 开头。以ox或0X开头的数字常量被认为式十六进制的值，字符 A-F既可以是大写，也可以是小写。

A：10；C:12；F：15

编写机器级程序的一个常见任务就是在位模式的十进制，二进制和十六进制表示之间人工转换。

![image-20230721135050164](.\img\image-20230721135050164.png)





### **二进制数据知识补充**

一般的硬盘生产厂商采用1,000,000,000（10）B = 1GB

Windows操作系统中的换算公式则是1 GB =1,073,741,824 B

数据量最小单位比特，bit，(b)即一个比特位为0或1

一个字节 ,Byte (B)等于8个比特 即 1B=8bit



与字节搭配时，K,M,G,T为二进制单位，因为1000与1024相近，即
$$
2^{10}=1K
$$
1 KB=1024 Byte ,所以1MB＝1024*1024＝1048576字节

1 MB=1024 KB

1 GB=1024 MB

1 TB=1024 GB

1 PB=1024 TB

1 EB =1024 PB

与比特搭配时 , K,M,G,T为十进制单位 , 即1K=1000

且bit常用来表示数据率，如bit/s , Kbit/s

换算为bit 时, 不要忘记乘以8，比如$1MB= 2^{20} *8=10485768bit$


$$
K=2^{10}=1024,

M=2^{20},

G=2^{30},

T=2^{40}
$$




### 2.1.2 字数据大小



不同计算机字长(word size)不同，用来指明指针数据的标称大小(nominal size),  ，

字长决定了虚拟地址空间的大小，

字长为$w$，则虚拟地址的范围为: $0 -> 2^w-1$，能访问的最大字节为$2^w$

32位的虚拟地址空间为 **4GB** 字节，约 $4*10^9$ 字节（1GB 约为$10^9$ B），

64 位字长的虚拟地址空间位 16 EB,大约 $1.84 * 10^{19}$字节。

**64 位机器的指针类型长度为 8 字节** 

64 位的机器可以运行32 位机器编译的程序, 即向后兼容

```
 >> gcc -m32 hello.c # 在32位和64位机器上都可以运行
 >> gcc -m64 hello.c # 只能在64位机器上运行
```

c 语言中的不同数据类型对应不同的字节数 (32 位机器和64位机器的对比)

![image-20230721155536940](.\img\image-20230721155536940.png)

注：对 32 位和 64 位机器而言，long的长度不一样。float 和 double 的长度一样，分别为 4，8,程序对 char 有无符号一般不敏感。

有符号 : 可以为负数 , 0 和 正数

无符号 : 只能为非负数

char : 单个字节 , 存储文本串中的单个字符

ISO C99 引入 int32_t 和 int64_t 的数据类型 , 来明确字节大小分别为 4字节( 24 =32) 和 8( 28 =64)字节

一般默认 没有标注unsigned 就是有符号数

int 有时可以省略 :

unsigned long 等价于 unsigned long int

long unsigned 等价于 long unsigned int

**char \* 表示一个指向 char 数据 类型的指针 , 使用全字长**

当32 位机器上的程序在64 位的机器上运行时 , 可能就会产生字长相关的问题



### **2.1.3 寻址和字节顺序**

对象的地址是什么，以及在内存中如何排列这些字节?

多字节对象都被存储为连续的字节序列，它的地址是它所用字节中的**最小地址**。

例如：

一个int x的地址为$0x100$, 地址表示式&x的值$0x100$。 那么，（假设数据类型int32表示）x的4个字节将被存储在内存()$0x100,0x101,0x102,0x103$)位置。

**这个地址可以采用两种字节存储法（针对变量的地址来说）：**

**小端法**（ big endian）：最低有效字节最前面（前就是最小地址）

**大端法**（little endian）：最高有效字节在最前面

假设变量x的类型为int,位于地址0x100处，它的十六进制值为0x01234567.地址范围$0x100,0x101,0x102,0x103$的字节顺序依赖于机器的类型：

![image-20230721142934189](.\img\image-20230721142934189.png)

许多 Intel 的兼容机 是小端模式，

IBM和oracle的大多数机器则是大端模式操作。

比较新的微处理器也有双端法(bi-endian)，即支持大端也支持小端），

实际情况是

一旦选择了特定操作系统，那么字节顺序也就固定下来。

在网络传输中 , 如何发送端和接受端的 模式不同 , 可能导致数据串是反序的 , 于是需要确定一个规范的网络标准

小端模式的的字节串不易阅读 , 比如 0x430b2000 会成为 0x00200b43 , 书写和阅读时 最高位往往在最左侧 , 而小端法的机器会在最右边 , 刚好相反



```
不同的CPU架构所采用的大小端模式也不同：
PowerPC、IBM、Sun的处理器采用大端表示法来表示内存和CPU数据。
Intel x86，DEC的处理器采用小端表示法来表示内存和CPU数据。
ARM可工作在大端模式也可工作在小端模式。

文件的数据也有大小端之分：
Adobe PS，JPEG，Windows下的ansi编码的txt文件，是大端表示法。
GIF，BMP文件是小端表示法。
```

> 端的说法起源:来自格列佛游记(Jonathan Swift) 的鸡蛋大端 和 小端之争历史的描述

### **typedef**

极大提高代码的可读性

```
 typedef int* int_pointer; 用int_pointer 这个别名来代替int*// 表示指向int类型的指针
 int_pointer ip; //1
 int* ip;//2
 // 1 和 2是等价的
```

**格式串format string输出 printf**

%d : 十进制整数

%f : 浮点数

%c : 输出一个字符

**数组和指针**

可以用数组表示发用来引用指针

也可以用指针表示法来引用数组元素

```
char start[10];
 start[i]; //1
 *(start+i);  //2
 //1 和 2 是等价的
```

**指针的创建和引用**

& : 取地址符

```
 int a;
 int* p=&a;
 // 还有 float* char*
```

强制类型转换不会改变数据 , 只是告诉编译器需要用新的数据类型来看待原始的数据

下面的程序可以得到不同程度对象的字节表示

```
#include <stdio.h>
 typedef unsigned char* byte_pointer;
 void show_bytes(byte_pointer start ,size_t len)
 {
     size_t i;
     for (i=0;i<len;i++)
         printf(" %.2x",start[i]);// 两位16进制数
     printf("\n");
 }
 // 用一个字节指针引用一个字节序列 , 每个字节被认为是一个非负整数
 // 于是就可一当作地址序列数组的首地址
 // sizeof 确定对象使用的字节数
 void show_int(int x){
     show_bytes((byte_pointer) &x,sizeof(int));//  sizeof(int) : 4
 }
 void show_float(float x){
     show_bytes((byte_pointer) &x,sizeof(float));// sizeof(float) : 4
 }
 void show_pointer(void *x){
     show_bytes((byte_pointer) &x,sizeof(void *));// sizeof(void *) : 8
 }
 void test_show_bytes(int val)
 {
     int ival=val;
     float fval=(float) ival;
     int* pval=&ival;
     show_int(ival);
     show_float(fval);
     show_pointer(pval);
 }
 int main()
 {
     test_show_bytes(12345);
 }    
```

**通过 man ascii 生成ASCII 字符码的表**

```
The following table contains the 128 ASCII characters.
 ​
 C program '\X' escapes are noted.
 │
 Oct   Dec   Hex   Char                      │ Oct   Dec   Hex   Char
 ────────────────────────────────────────────┼───────────────────────────
 000   0     00    NUL '\0' (null character) │ 100   64    40    @
 001   1     01    SOH (start of heading)    │ 101   65    41    A
 002   2     02    STX (start of text)       │ 102   66    42    B
 003   3     03    ETX (end of text)         │ 103   67    43    C
 004   4     04    EOT (end of transmission) │ 104   68    44    D
 005   5     05    ENQ (enquiry)             │ 105   69    45    E
 006   6     06    ACK (acknowledge)         │ 106   70    46    F
 007   7     07    BEL '\a' (bell)           │ 107   71    47    G
 010   8     08    BS  '\b' (backspace)      │ 110   72    48    H
 011   9     09    HT  '\t' (horizontal tab) │ 111   73    49    I
 012   10    0A    LF  '\n' (new line)       │ 112   74    4A    J
 013   11    0B    VT  '\v' (vertical tab)   │ 113   75    4B    K
 014   12    0C    FF  '\f' (form feed)      │ 114   76    4C    L
 015   13    0D    CR  '\r' (carriage ret)   │ 115   77    4D    M
 016   14    0E    SO  (shift out)           │ 116   78    4E    N
 017   15    0F    SI  (shift in)            │ 117   79    4F    O
 020   16    10    DLE (data link escape)    │ 120   80    50    P
 021   17    11    DC1 (device control 1)    │ 121   81    51    Q
 022   18    12    DC2 (device control 2)    │ 122   82    52    R
 023   19    13    DC3 (device control 3)    │ 123   83    53    S
 024   20    14    DC4 (device control 4)    │ 124   84    54    T
 025   21    15    NAK (negative ack.)       │ 125   85    55    U
 026   22    16    SYN (synchronous idle)    │ 126   86    56    V
 027   23    17    ETB (end of trans. blk)   │ 127   87    57    W
 030   24    18    CAN (cancel)              │ 130   88    58    X
 031   25    19    EM  (end of medium)       │ 131   89    59    Y
 032   26    1A    SUB (substitute)          │ 132   90    5A    Z
 033   27    1B    ESC (escape)              │ 133   91    5B    [
 034   28    1C    FS  (file separator)      │ 134   92    5C    \  '\\'
 035   29    1D    GS  (group separator)     │ 135   93    5D    ]
 036   30    1E    RS  (record separator)    │ 136   94    5E    ^
 037   31    1F    US  (unit separator)      │ 137   95    5F    _
 040   32    20    SPACE                     │ 140   96    60    `
 041   33    21    !                         │ 141   97    61    a
 042   34    22    "                         │ 142   98    62    b
 043   35    23    #                         │ 143   99    63    c
 044   36    24    $                         │ 144   100   64    d
 045   37    25    %                         │ 145   101   65    e
 046   38    26    &                         │ 146   102   66    f
 047   39    27    '                         │ 147   103   67    g
 050   40    28    (                         │ 150   104   68    h
 051   41    29    )                         │ 151   105   69    i
 052   42    2A    *                         │ 152   106   6A    j
 053   43    2B    +                         │ 153   107   6B    k
 054   44    2C    ,                         │ 154   108   6C    l
 055   45    2D    -                         │ 155   109   6D    m
 056   46    2E    .                         │ 156   110   6E    n
 057   47    2F    /                         │ 157   111   6F    o
 060   48    30    0                         │ 160   112   70    p
 061   49    31    1                         │ 161   113   71    q
 062   50    32    2                         │ 162   114   72    r
 063   51    33    3                         │ 163   115   73    s
 064   52    34    4                         │ 164   116   74    t
 065   53    35    5                         │ 165   117   75    u
 066   54    36    6                         │ 166   118   76    v
 067   55    37    7                         │ 167   119   77    w
 070   56    38    8                         │ 170   120   78    x
 071   57    39    9                         │ 171   121   79    y
 072   58    3A    :                         │ 172   122   7A    z
 073   59    3B    ;                         │ 173   123   7B    {
 074   60    3C    <                         │ 174   124   7C    |
 075   61    3D    =                         │ 175   125   7D    }
 076   62    3E    >                         │ 176   126   7E    ~
 077   63    3F    ?                         │ 177   127   7F    DEL
 ​
 Tables
 For convenience, below are more compact tables in hex and decimal.
 ​
 2 3 4 5 6 7       30 40 50 60 70 80 90 100 110 120
 -------------      ---------------------------------
 0:   0 @ P ` p     0:    (  2  <  F  P  Z  d   n   x
 1: ! 1 A Q a q     1:    )  3  =  G  Q  [  e   o   y
 2: " 2 B R b r     2:    *  4  >  H  R  \  f   p   z
 3: # 3 C S c s     3: !  +  5  ?  I  S  ]  g   q   {
 4: $ 4 D T d t     4: "  ,  6  @  J  T  ^  h   r   |
 5: % 5 E U e u     5: #  -  7  A  K  U  _  i   s   }
 6: & 6 F V f v     6: $  .  8  B  L  V  `  j   t   ~
 7: ' 7 G W g w     7: %  /  9  C  M  W  a  k   u  DEL
 8: ( 8 H X h x     8: &  0  :  D  N  X  b  l   v
 9: ) 9 I Y i y     9: '  1  ;  E  O  Y  c  m   w
 A: * : J Z j z
 B: + ; K [ k {
 C: , < L \ l |
 D: - = M ] m }
 E: . > N ^ n ~
 F: / ? O _ o DEL
```



### **2.1.4 表示字符串**

c 语言中的字符串用一个null (数值为0) 来结尾 的字符数组表示

每个字符是一个ASCII 的编码

"12345" -> 0x31 0x32 0x33 0x34 0x35 0x00

十进制表示 : 49 50 51 52 53 0 (我们都知道 '0' 的编码为48)

即 十进制 m 的ASCII 编码恰好是 0x3m



### **2.1.5 字符编码的标准**



ASCII 字符集适合英文文档的编码 , 不适合其他语言的编码

于是提出了 Unicode 标准来包括100000个字符, 支持了更加的语言种类 , 甚至包括古埃及的语言

Unicode 就是"统一字符集" , 用32 位bit 来表示字符 , 即 4个byte 的大小可以用来编码

但实际上常见的字符只需要1个 或者两个字节, 不常用的字符需要更多一点

UTF-8 的单个字符编码和ASCII 一样, 即 ASCII 字节序列用ASCII 码表示和用UTF-8 表示是一样的

Java 语言已经使用了Unicode来表示字符串



在机器看来 , 程序仅仅是字节序列, 机器中没有任何源于源程序的信息

在不同的机器 , 不同的操作系统上的c语言代码编译后产生的机器代码也是不同的

即 不同的二进制代码是不兼容的 , 很难进行移植

如何获取c程序编译的汇编程序和二进制代码?

先编写一个程序 demo.c

```
 int sum(int x,int y)
 {
     return x+y;
 }
```

得到汇编程序

```
 $ gcc -O1 -S demo.c
 #得到 demo.s 的汇编文件
 #-O1 表示第一级优化 (字母O)
 $ cat demo.s 
 -------------
         .file   "demo.c"
        .text
        .globl  sum
        .type   sum, @function
sum:
.LFB0:
        .cfi_startproc
        endbr64
        leal    (%rdi,%rsi), %eax
        ret
        .cfi_endproc
        .....
```

得到二进制文件

```
 gcc -O1 -c demo.c
 #得到demo.o 的二进制文件
  #-O1 表示第一级优化 (字母O)
```

查看二进制文件

可以通过反汇编器（将二进制格式文件反汇编为汇编代码文本）进行查看

```
$ objdump -d demo.o

demo.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <sum>:
   0:   f3 0f 1e fa             endbr64
   4:   8d 04 37                lea    (%rdi,%rsi,1),%eax
   7:   c3                      retq
   
```

用xxd 也可以直接查看二进制文件

### **2.1.6 布尔代数**

二进制是计算机存储信息的核心

Boolean algebra 布尔代数 围绕0和1 展开了对于逻辑推理的研究

TRUE (真) : 1

FALSE (假) : 0

~ : 逻辑非 NOT (1 变0 , 0 变1) 

& : 逻辑与 AND (都为1 才是1 , 否则是0) 

| : 逻辑或 OR (都为0 才是0 , 否则是1) 

^ : 逻辑异或 EXCLUSIVE-OR (相同就是0 , 不同就是1)

![img](.\img\v2-763f1ba1add179f49bbff49c8966d900_1440w.webp)
$$
四种逻辑运算
$$
位向量 : 固定长度为 w , 0 和1 组成的串

a & b : 表示a的每一位和b的每一位进行逻辑与 ( $a_i \& b_i, 0<=i<w$)​

![image-20230721163352906](.\img\image-20230721163352906.png)

### **2.1.7 C 语言中的位级运算**

位运算的常见应用是实现**掩码**。掩码表示从一个字中选出的位的集合，如掩码 0xFF 表示一个字的低 8

位。表达式 **~0** 可以生成一个全 1 的掩码，不管机器的字大小是多少。

### **2.1.8 C 语言中的逻辑运算**

逻辑运算符 && 和 || 如果第一个参数就能确定结果，就不再计算第二个参数

### **2.1.9 C 语言中的移位运算**



移位运算具有 结合性 : (i<<j)<<k =i<<(j<<k)



左移k位 : x<<k , 即 丢弃左侧的k 位最高位 , 然后右侧补k 个0

逻辑右移 : x>>k , 丢弃右侧的k位最低位 ,然后左侧补 k 个0

算术右移 : x>>k , 丢弃右侧的k位最低位 ,然后左侧补 k个最高有效位



如果 右移没有确定(到底是逻辑右移 还是 算术右移 都会导致代码的移植性较差)

实际上 大部分的有符号数都使用算数右移

而对于无符号数必须使用逻辑右移

java 有明确的规定 :

x >> k 是算术右移

x >>>k 是逻辑右移

## **2.2 整数表示**

无符号表示与补码表示

有符号数到无符号数的转换会产生漏洞，**避免错误的方法之一是绝不使用无符号数**。

除了 C 以外**很少有语言支持无符号整数**，Java 就只支持有符号数

### **2.2.1 整数数据类型**

在 64 位系统上

i**nt**：4字节，可表示十进制数字位数：**10****位（****-20~20****亿以内）**

**long long**：8字节，可表示十进制数字位数：**19****位（千亿亿级）**

long：8字节

**double**：8字节，**精度****15****位**，可表示十进制数字位数**308****位**

**float**：4字节，**精度****6****位**，可表示十进制数字**38****位**

**char**：**-128~127**

java 只支持有符号数。

### **2.2.2 无符号数的编码**

无符号表示、补码表示与数据的映射都是双射，即一一对应。

### **2.2.3 补码编码**

补码的定义实际就是**将符号位解释为负权**。

C 库头文件 <limit.h> 定义了一组常量来限定不同整数数据类型的取值范围。INT_MAX、INT_MIN、

UINT_MAX

C 库头文件 **<stdint.h>**中定义了 uint16_t, int32_t 等类型，用于声明确定宽度类型的整数。

### **2.2.4 有符号数和无符号数之间的转换**

在有符号数与无符号数之间进行强制类型转换的结果是**保持位值不变，只改变解释位的方式。**

**补码 x 转无符号数**

x >= 0，值不变

x < 0，转换后的值为 2^w + x**无符号数 x 转补码**

x < 2^(w-1)，值不变

x >= 2^(w-1)，转换后的值为 x - 2^w

### **2.2.5 C 语言中的有符号数和无符号数**

C 语言中有符号数和无符号数相加减，有符号被转换成无符号。

### **2.2.6 扩展一个数字的位表示**

扩展无符号数使用零扩展，即在最高位前加 0

扩展有符号数使用符号扩展，即在最高位前加最高有效位的值

### **2.2.7 截断数字**

对一个 w 位的数字截断为一个 k 位数字，将丢弃高 w-k 位。

对于无符号数而言，截断后的数字实际上等于 w mod 2^k，即取余。

## **2.3 整数运算**

### **2.3.1 无符号加法**

考虑溢出，C 语言不会将溢出作为错误发出信号

当 x+y >= 2^w，实际结果为 s = x+y-2^w

对任意的 x+y，**s = (x+y) % 2^w**

**溢出的结果：**和小于两个加数

**检验溢出的方式：**如果 **s<x**，说明溢出

**无符号数的非**：~x = 2^w - x (x>0)

### **2.3.2 补码加法**

当 x+y >= 2^(w-1)， s = x+y-2^w

当 x+y < -2^(w-1)，s = x+y+2^w

**正溢出的结果是负数，负溢出的结果是正数。**

**检验溢出的方式：**当 x,y>0 而 s<=0 是正溢出；当 x,y<0 而 s>=0 是负溢出

### **2.3.3 补码的非**

当 x = TMin，-x = TMin；当 x ≠ TMin，-x = -x

**补码非的位级表示：****对每一位求补，结果再加 1**

**计算补码非的第二种方法：**假设 k 是最右边的 1 的位置，对 k 左边的所有位取反

### **2.3.4 无符号乘法**

**无符号乘法的积** **m = (x\*y) % 2^w****2.3.5 补码乘法**

可以认为补码乘法和无符号乘法的**位级表示**是一样的

C语言在运算时将 x,y 视为无符号数进行乘法运算，结果取余后将其按补码方式解释

**补码乘法的积** **m = (x\*y) % 2^w**

### **2.3.6 乘以常数**

大多数机器上，整数乘法需要 **10 个或更多**的时钟周期，而加法、减法、位级运算和移位只需要 1 个

时钟周期

**编译器对整数乘法进行优化的方式**：用**移位和加法或减法**运算的组合来代替常数因子的乘法。

左移 k 位等于乘以 2^k

如 x * 14 = (x<<3)+(x<<2)+(x<<1) = (x<<4)-(x<<2)

**判断如何移动的方式**很简单：14 的位级表示为 1110，所以分别左移 3，2，1

### **2.3.7 除以 2 的幂**

大多数机器上，整数除法更慢，需要 **30 个或更多**的始终周期。

（只有）除以 2 的幂可以用移位运算来代替，**无符号采用****逻辑右移****，补码采用****算术右移**

对于有符号数而言，算术右移的结果相当于进行除法运算后**向下舍入**

使用 **(x+(1<<k)-1)>>k** 的结果相当于进行除法运算然后**向零舍入**

代码实现

1 (x<0 ? x+(1<<k)-1 : x) >> k;

**2.3.8 关于整数运算的最后思考**

**补码使用了与无符号算术运算相同的位级实现**，包括加法、减法、乘法甚至除法。都有完全一样或非

常类似的位级行为。

## **2.4 浮点数**

浮点数对于非常大，非常接近零，近似值计算都很有用

### **2.4.1 二进制小数**

小数的二进制表示法只能表示那些能够写为 **x \* 2^w** 的数，**其他的数都是近似表示。x 必须可以由形**

**如 2^i + 2^j + ... + 2^n 的多项式表示**

浮点运算的不精确性可能产生严重后果

### **2.4.2 IEEE 浮点表示**



**IEEE 浮点标准**的表示形式为：**V = (-1)^S \* M \* 2^E**，它分为三部分：

**1.** **符号**：**S** 决定是负数还是正数

**2.** **阶码**：**E** 的作用是对浮点数加权

**3.** **尾数**：**M** 是一个二进制小数，范围是 1~2-ε 或 0~1-ε

**在对浮点数的位编码**时：

\1. 一个单独的符号位编码直接编码 S

\2. k 位的**阶码字段** **e** 编码 E；float 中 k=8，double 中 **k=11**

\3. n 位的**小数字段** **f** 编码 M；float 中 n=23，double 中 **n=52**

E 和 M 的编码方式分为**三种情况**：

**1. 规格化的值：**阶码字段即不全为 0 也不全为 1 时属于规格化值（0001~1110）

a. 阶码字段解释方式：**E = e - (2^(k-1)-1)**；如 k=4 时，E 的范围是 -6~7；单精度为 -126~127

b. 小数字段解释方式：**M = 1 + f**

**2. 非规格化的值**：阶码字段全为 0 时属于非规格化形式

a. 阶码字段解释方式：**E = 1 - (2^(k-1)-1)**；**与规格化值中** **e = 1** **时的** **E** **相同**

b. 小数字段解释方式：**M = f**

**3. 特殊值：**阶码字段全为 1 时，分两种情况：

**a. 小数字段全为** **0****：表示无穷**

**b. 小数字段非零：表示** **NaN****。**比如 ∞-∞ 的结果就返回 NaN

### **2.4.3 数字示例**

0 有 +0.0 和 -0.0 两种表示方式

最大非规格化数到最小规格化数的过渡是平滑的。

浮点数能够使用正数排序函数来排序，即浮点数的位级表示当用整数方式来解释时是顺序的（正数升

序负数降序）。

浮点数可表示的数的分布是不均匀的，越接近零时越稠密

**几个特殊的值的位级表示：**

\1. +0.0 全为 0

**2.** **最小的正非规格化值：**最低有效位为 1，其他为 0

**3.** **最大的非规格化值：**小数字段全为 1，其他为 0

**4.** **最小的正规格化值：**阶码字段最低位为 1，其他为 0

**5.** **最大的规格化值：**阶码字段最低位为 0，符号位为 0，其他为 1

### **2.4.4 舍入**

因为范围和精度有限，浮点运算只能近似表示实数运算。

在浮点数的近似匹配上，IEEE 浮点格式定义了**四种舍入方式（默认第一种）：**

**1. 向偶数舍入（向最接近的值舍入）**：非中间值 (0.5) 四舍五入，中间值向偶数舍入。

\2. 向零舍入

\3. 向下舍入

\4. 向上舍入

向偶数舍入可以计算一组数的平均数时避免统计偏差。实际上这种舍入是发生在二进制小数上的。

### **2.4.5 浮点运算**

IEEE 标准定义 1/-0 = -∞，1/+0 = +∞

浮点运算是**可交换不可结合也不可分配**的。

浮点加法满足**加法和乘法上的单调性**。如果 a>=b，则 x+a >= x+b

缺乏结合性和分配性会使一些简单问题变得很复杂

### **2.4.6 C 语言中的浮点数**

在 int、float、double 间进行**强制类型转换时的几种情况：**

\1. int 到 float：不会溢出，可能舍入

\2. int 或 float 到 double：不会溢出也不会舍入

\3. double 到 float：可能溢出和舍入

**4.** **float** **或** **double** **到** **int****：**向零舍入，很大时可能溢出，很接近零时也可能溢出。当从浮点转换到整数时如果溢出，

转变结果都为 [1000]，因此一个正浮点可能得到一个负整数

**把大的浮点数转换为整数是一种常见的错误。**

要小心地使用浮点运算

## 2.5 问题集

**问题 2.1~2.2**

\1. 十六进制中 A,C,F 分别是多少。

\2. 如何定义有确定字长的整数，在哪个头文件中

\3. 计算机的字长是什么？字长决定了什么？

\4. short, int, long long 长度分别是多少，long 长度是多少

\5. 一个 int 对象的地址是它所占哪个字节的地址

\6. 多字节类型的小端法和大端法分别是什么，一般计算机是哪种方法

\7. ASCII 和 Unicode 分别应用于哪些情况？两者的关系是什么

8. 掩码是什么？如何生成全 1 的数字

\9. 什么是逻辑右移和算术右移，有符号数用哪个？无符号数用哪个

\10. int, long long, char，short 可表示的范围分别是多少

\11. float, double 的精度和可表示范围分别是多少

\12. 补码如何解释位

\13. 有符号数和无符号数的强制类型转换是如何转换的

\14. 有符号转无符号数值如何变化？无符号转有符号数值如何变化？

\15. 如何扩展有符号数？如何扩展无符号数？

\16. 截断一个无符号数从数学运算上如何理解？

**回答**

\1. A 是 10，C 是 12，F 是 15

\2. 使用 int32_t, int64_t, uint32_t, uint64_t。定义在头文件 <stdint.h> 中

\3. 32 位计算机的字长是 32 位，64 位计算机的字长是 64 位，字长w决定了虚拟空间的大小：$<= 2^w$。

\4. 分别是 2，4，8 位，long 在 32 位程序中是 4 位，在 64 位机器中是 8位

\5. 最小字节的地址

\6. 小端法将低位表示在低字节，大端法将高位表示在低字节。大部分是小端法。

\7. ASCII 用于英文文档，UTF-8 用于多语言，所有的 ASCII 字符在 UTF-8 中是一样的

\8. 掩码用来筛选一个数字的某几位，~0 的结果是全 1

\9. 逻辑右移左边补 0，算术右移左端补符号位，有符号数用算术右移，无符号数用逻辑右移

\10. 10位，-20亿~20亿； 19位，千亿亿级； -128~127；-32768~32767

**11.** **6****位**，10 的 38 次方以内；**15****位**，10 的 308 次方以内；

\12. 最高位解释为负权

\13. 位值不变，改变解释的方式

\14. int x<0, ux = x + 2^w；unsigned int ux >= 2^(w-1), x = ux - 2^w；

\15. 左端填充为符号位；左端填充为 0

\16. 对 2^k 取模

**问题 2.3~2.4**

\1. 考虑溢出，无符号加法的计算公式，无符号乘法的计算公式？如何检验溢出？

\2. 考虑溢出，补码加法的计算公式，补码加法溢出的特点是什么？如何检验溢出？

\3. 考虑溢出，补码乘法的计算方法

\4. 补码的非怎么求？

\5. 整数乘法的计算速度？整数乘法的优化方式？如何判断移动的方式？

\6. 整数除法的计算速度？除以 2 的幂的优化方式？

\7. 整数补码运算与无符号运算的关系

\8. 浮点数表示法的限制

\9. 浮点数位级表示的三个部分？double 分别有多少位？

\10. 阶码和尾数的三种编码方式分别是什么？

\11. 最小的正非规格化值、最大的非规格化值、最小的正规格化值、最大的规格化值的位级表示分别是怎样的？

\12. 什么是向偶数舍入？浮点数的近似匹配采用哪种舍入方式？有什么优点13. 浮点运算满足什么运算性质？不满足什么性质？

\14. 从 float 或 double 转换到 int 可能会发生什么情况？

**回答**

\1. s=(x+y)%2^w；m=(x*y)%2^w；检验加法溢出：s<x 或 s<y

\2. 分三种情况，不溢出，正溢出，负溢出；特点：正溢出的结果是负数，负溢出的结果是正数；检验溢出：结果变号

了就是溢出了

\3. 将两个乘数当成无符号数进行乘法计算，截断溢出的部分后，将剩余部分用补码方式解释

\4. 按位求反再加一

\5. 大于等于 10 个时钟周期；用移位+加法/减法优化；根据移位程度 k 的位级表示来判断

\6. 大于等于 30 个时钟周期；逻辑右移或算术右移；算术右移的结果是向下舍入，可以调整为向零舍入

\7. 在位级表示上完全相同或非常相似

\8. 只能表示 x * 2^y 类的数，其他数字只能近似表示

\9. 符号、阶码、尾数；1，11位，52位

\10. 规格化值：阶码非全 0 非全 1，减去 2^(k-1)-1，尾数+1；非规格化值：阶码全 0，值为 1 - (2^(k-1) - 1)，尾数不变；特殊值：阶码全 1，尾数全 0 表示无穷，尾数非全 0 表示 NaN

\11. 末位为1，其他为0；尾数全1，其他全0；阶码末位为1，其他全0；阶码末位和符号位为0，其他全1；

\12. 非中间值向近舍入，中间值向偶数舍入；采用向偶数舍入；优点是统计结果不偏差

\13. 满足交换性和单调性，不满足结合性和分配性

\14. 可能溢出和舍入；如果溢出，转换结果都是 100000，是一个负数。

### 参考资料

1. https://zhuanlan.zhihu.com/p/466726000
2. https://hansimov.gitbook.io/csapp/part1/ch02-representing-and-manipulating-information