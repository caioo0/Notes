# 汇编语言之转移指令的原理

可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。

8086CPU的转移行为有以下几类。

- 只修改IP时，称为段内转移，比如：jmp ax。

- 同时修改CS和IP时，称为段间转移，比如：jmp 1000:0。

  

由于转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移。

1. 短转移IP的修改范围为-128 ~ 127。

2. 近转移IP的修改范围为-32768 ~ 32767。

  

8086CPU的转移指令分为以下几类。

- 无条件转移指令（如：jmp）
- 条件转移指令
- 循环指令（如：loop）
- 过程
- 中断

## 1、操作符offset

操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。

```
;将s处的一条指令复制到s0处
assume cs:codesg
codesg segment
 s:   mov ax, bx           ;（mov ax,bx 的机器码占两个字节）
      mov si, offset s     ;获得标号s的偏移地址
      mov di, offset s0    ;获得标号s0的偏移地址
      
      mov ax, cs:[si]
      mov cs:[di], ax
 s0:  nop                     ;（nop的机器码占一个字节）
      nop
 codesg ends
 ends

```

## 2、jmp指令

jmp为无条件转移，转到标号处执行指令可以只修改IP，也可以同时修改CS和IP；

jmp指令要给出两种信息：

转移的目的地址
转移的距离（段间转移、段内短转移，段内近转移）
 jmp short 标号 jmp near ptr 标号 jcxz 标号 loop 标号 等几种汇编指令，它们对 IP的修改

是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离。


### 1、依据位移进行转移的jmp指令

jmp short 标号（段内短转移）

指令“jmp short 标号”的功能为(IP)=(IP)+8位位移，转到标号处执行指令

（1）8位位移 = “标号”处的地址 - jmp指令后的第一个字节的地址；

（2）short指明此处的位移为8位位移；

（3）8位位移的范围为-128~127，用补码表示

（4）8位位移由编译程序在编译时算出。


```
assume cs:codesg
codesg segment
  start:mov ax,0
        jmp short s ;s不是被翻译成目的地址
        add ax, 1
      s:inc ax ;程序执行后， ax中的值为 1 
codesg ends
end start

```

CPU不需要这个目的地址就可以实现对IP的修改。这里是依据位移进行转移

jmp short s指令的读取和执行过程：

(CS)=0BBDH，(IP)=0006，上一条指令执行结束后CS:IP指向EB 03（jmp short s的机器码）；
读取指令码EB 03进入指令缓冲器；
(IP) = (IP) + 所读取指令的长度 = (IP) + 2 = 0008，CS:IP指向add ax,1；
CPU指行指令缓冲器中的指令EB 03；
指令EB 03执行后，(IP)=000BH，CS:IP指向inc ax
jmp near ptr 标号 （段内近转移）

指令“jmp near ptr 标号”的功能为：(IP) = (IP) + 16位位移。
2、转移的目的地址在指令中的jmp指令
jmp far ptr 标号（段间转移或远转移）

指令 “jmp far ptr 标号” 功能如下：

(CS) = 标号所在段的段地址；
(IP) = 标号所在段中的偏移地址。
far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。

```
assume cs:codesg
codesg segment
   start: mov ax, 0
		  mov bx, 0
          jmp far ptr  s ;s被翻译成转移的目的地址0B01 BD0B
          db 256 dup (0) ;转移的段地址：0BBDH，偏移地址：010BH
    s:    add ax,1
          inc ax
codesg ends
end start

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190322151439754.png)

### 3、转移地址在寄存器或内存中的jmp指令

```
jmp 16位寄存器` 功能：`IP =（16位寄存器）
```

转移地址在内存中的jmp指令有两种格式：

- `jmp word ptr 内存单元地址`（段内转移）

功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。

```
mov ax, 0123H
mov ds:[0], ax
jmp word ptr ds:[0]
;执行后，(IP)=0123H

```

- `jmp dword ptr 内存单元地址`（段间转移）

功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。

1. (CS)=(内存单元地址+2)
2. (IP)=(内存单元地址)

```
mov ax, 0123H
mov ds:[0], ax;偏移地址
mov word ptr ds:[2], 0;段地址
jmp dword ptr ds:[0]
;执行后，
;(CS)=0
;(IP)=0123H
;CS:IP 指向 0000:0123。

```

4、jcxz指令和loop指令
jcxz指令

jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，

在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。

指令格式：jcxz 标号（如果(cx)=0，则转移到标号处执行。）

当(cx) = 0时，(IP) = (IP) + 8位位移

8位位移 = “标号”处的地址 - jcxz指令后的第一个字节的地址；
8位位移的范围为-128~127，用补码表示；
8位位移由编译程序在编译时算出。
当(cx)!=0时，什么也不做（程序向下执行）

loop指令

loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。

对IP的修改范围都为-128~127。

指令格式：loop 标号 ((cx) = (cx) - 1，如果(cx) ≠ 0，转移到标号处执行)。

(cx) = (cx) - 1；如果 (cx) != 0，(IP) = (IP) + 8位位移。

8位位移 = 标号处的地址 - loop指令后的第一个字节的地址；
8位位移的范围为-128~127，用补码表示；
8位位移由编译程序在编译时算出。
如果（cx）= 0，什么也不做（程序向下执行）。
