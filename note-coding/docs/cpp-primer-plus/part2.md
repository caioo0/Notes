**问题**

1. 指针和引用有4点不同，分别是哪些？
2. const 对象必须怎样
3. const 对象的作用范围
4. **什么是常量引用，如何声明，是顶层还是底层**
5. 常量引用与常量对象、非常量对象的关系。
6. **什么是常量指针，如何声明，是顶层还是底层**
7. 常量指针与常量对象、非常量对象的关系。
8. 顶层 const 和底层 const 都是什么，在什么位置
9. **如何区分顶层 const 和底层 const**
10. constexpr 是什么，特点是什么

**回答**

1. 指针是对象而引用不是；指针可以重定向引用不可以；有指向指针的指针无引用的引用；引用必须初始化指针不需要
2. 必须初始化
3. 默认范围是文件内
4. **不能改变对象的引用是常量引用，const int& i = a，是底层 const**
5. 不能用非常量引用绑定常量对象，可以用常量引用绑定非常量对象。
6. **常量指针表明指针是个常量，其内存储的地址不能改变，但是指针还能修改所指对象的值。int\* const p = a，是顶层const。**
7. 可以用常量指针指向非常量对象。
8. **顶层 const 表示指针本身是常量，底层 const 表示所指对象是常量****。顶层 const 在右边，底层 const 在左边**
9. **只有指针同时有顶层和底层，const 在星号右边是顶层，左边是底层。引用的 const 是底层，其他类型 const 是顶层。**
10. 常量表达式。两个点：值不能改变、**在编译阶段就可以计算出值**

**问题**

1. 浮点数赋给整型变量时如何舍入？
2. decltype 是什么，如何使用
3. 如何声明而非定义一个变量
4. 如果指针不初始化会有什么影响
5. 如何在多个文件间共享 const 对象
6. 使用 auto 来定义引用时要注意什么
7. 预处理变量的作用范围是什么
8. C++属于静态类型语言，静态类型语言的含义是什么？
9. C++有两种定义类型别名的方式，分别是什么

**回答**

1. 只保留小数点前的部分，即向零舍入
2. 用来获取变量类型，decltype(c) a;
3. 使用 extern 修饰符： extern int i:
4. 在块作用域中，未初始化的指针的值是未定义的。
5. 如果想在多个文件间共享const对象，必须在变量的定义前添加**extern**关键字并在本文件中声明。**声明和定义都要加extern**
6. 用 auto 定义引用时，必须要加 & 符号。尤其是在范围 for 循环中，当想要修改值时，一定要记得加上引用符。
7. 文件内。
8. 静态类型语言在编译时检查变量类型。
9. typedef unsigned int size_type 和 using size_type = unsigned int;

**第2章 变量和基本类型**

C++定义了几种基本内置类型，如字符、整型、浮点数等。

**2.1 基本内置类型**

基本内置类型包括算数类型和空类型。算数类型包括字符、整型数、浮点数和布尔值。

**2.1.1 算术类型**

算数类型分为整型和浮点型两类。字符和布尔值都属于整型。

C++ 定义了**各类型的最小尺寸**：bool 未定义、char 8位、short 16位、int 16位、long 32位、long long 64位；

float 是 32 位 4 字节，包括6位有效数字、double 是 64 位 8 字节，包括10位有效数字。

​    ![0](https://note.youdao.com/yws/public/resource/12f60d70f1170c9b3d6a40ee9f25a63f/xmlnote/86D0C17890A14BF4B5D7BD60996945E0/52498)

int、short、long 都是带符号类型。char 是否有符号由编译器决定。

因为 char 是否有符号并不确定，因此可以使用 signed char 或 unsigned char 来指定是否有符号。

C++ 提供了几种字符类型：

1. char：一个 char 的空间应确保可以存放机器基本字符集中任意字符对于的数字值，即一个 char 的大小和一个机器字节一样。
2. wchar_t：宽字符，用于扩展字符集，wchar_t 确保可以存放机器最大扩展字符集中的任意一个字符。
3. char16_t 和 char32_t：为 Unicode 字符集服务。

**类型选择：**

明确知晓数值不可能为负时，选用无符号类型。

整数运算用 int，数值太大时用 long long，不用 short 和 long

浮点数运算用 double。float 和 double 的计算代价相差无几

**2.1.2 类型转换**

几种类型转换的情况：

1. 把浮点数赋给整型时，结果**仅保留小数点前的部分**。
2. 赋给无符号类型超出范围的值时，结果是**初始值对无符号类型表示数值总数取模后的余数**。比如 -1 赋给 8 位 unsigned char 的结果是 255（-1=256*(-1)+255）
3. **赋给带符号类型超出范围的值时，结果是未定义的**。程序可能工作，可能崩溃。

程序尽量避免依赖于实现环境的行为。比如 int 的尺寸在不同环境可能不同。

**含有无符号类型的表达式**

一个表达式中既有无符号数又有int值时，**int会被转换成无符号数**。

**无符号减无符号数，结果还是无符号数，如果是负值就等于该符数加上无符号数的模**

​                unsigned u = 10; int i = -42; u + i = -32 + 2^32 = 4294967264              

**2.1.3 字面值常量**

**整型和浮点型字面值**

整型字面值中 0 开头的整数是 8 进制，0x 开头的整数是十六进制。

整型字面值的具体数据类型由它的值和符号决定。默认情况下十进制字面值是带符号数，类型是 int, long, long long 中能容纳当前值的尺寸最小的那个。

浮点型字面值可以用小数或科学计数法表示，科学计数法中的指数部分用 E 或 e 标识。

​                3.14   0.  0e0  .001  3.14E2              

**字符和字符串字面值**

单引号括起来的一个字符是 char 型字面值，双引号括起来的 0 个或多个字符则构成字符串型字面值。

字符串字面值的类型实际上是字符数组，编译器会向每个字符串结尾添加一个空字符（'\0'），因此字符串字面值的实际长度要比它的内容多 1。如 “A” 代表了一个长度为 2 的字符数组。

如果两个字符串字面值紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。因此字符串比较长时可以直接分行书写。

​                "A is B"   "and B is A"; //两个字符串实际上是一个整体。              

**转义序列**

C++ 定义的转移序列包括：

换行符：\n，横向制表符：\t,，报警符：\a，纵向制表符：\v，退格符：\b，**双引号：\"，**

**反斜线：\\，单引号：\'**，**问号：\?**，回车符：\r，进纸符：\f

在程序中，上述转义序列被当作一个字符使用。

也可以使用泛化的转移序列，形式是 / 后跟 1~3 个八进制数字或 \x 后跟 1 个或多个十六进制数字。

​                \0     //空字符 \12    //换行符 \40    //空格 \x4d   //字符 M \115   //字符 M              

**指定字面值的类型**

可以通过给字面值增加前缀和后缀来改变字面值的默认类型。

​                '整型字面值' 12          // 默认类型为 int 12u  12U    // 最小匹配类型 unsigned 12l  12L    // 最小匹配类型 long 12ul 12UL   // 最小匹配类型 unsigned long 12ll 12LL   // 最小匹配类型 long long 12ull 12ULL // 最小匹配类型 unsigned long long '浮点型字面值' 3.14          // 默认类型为 double 3.14f  3.14F  // 类型为 float 3.14l  3.14L  // 类型为 long double '字符字符串字面值' u'a'  u"abandon"   // Unicode 16 字符，类型为 char16_t U'a'  U"abandon"   // Unicode 32 字符，类型为 char32_t L'a'  L"abandon"   // 宽字符，类型为 wchar_t u8"abandon"        // 类型为 char，u8 的含义是 UTF-8，仅用于字符串字面值。              

注意 12f 是错的，不能给整型字面值加 f 后缀，可以使用 12.f。

**布尔字面值和指针字面值**

​                true false // bool 类型的字面值 nullptr    // 指针字面值              

**2.2 变量**

对于c++而言，”变量“和”对象“一般可以互换使用。

c++中，**对象**通常指一块能存储数据并具有某种类型的内存

**2.2.1 变量定义**

**初始化**

可以在同一条定义语句中使用先定义的变量去初始化后定义的其他变量。

​                double price = 109.99, discount = price * 0.6;              

初始化不是赋值，初始化是创建变量时赋予一个初始值，赋值是把对象的当前值**擦除**并用一个新值来替代。

**列表初始化**

下面四种初始化方式都是可行的，其中使用花括号的方式叫做列表初始化。

​                int i=0;  int i={0};  int i{0};  int i(0);              

当用于内置类型的变量时，使用列表初始化且初始值存在信息丢失的风险，编译器会报错。

​                long double ld = 3.1415926536; int a{ld}, b={ld};  //错误，存在信息丢失的风险，转换未执行。 int c(ld), d=ld;    //正确              

**默认初始化**

定义于函数体内的内置类型的对象如果没有初始化，则其值**未定义**。定义于任何函数之外的内置类型则被初始化为0；

类的对象如果没有显式地初始化，则其由类确定。string 默认初始化为一个空串。

不能使用未初始化的变量，否则会引发运行时故障。

**建议初始化每一个内置类型的变量。**

**2.2.2 变量声明和定义的关系**

**声明**和**定义**是严格区分的。

要声明一个变量加 extern，声明变量不能赋值。

任何包含了显式初始化的声明即成为定义。

​                extern int i;     // 声明 i int i;            // 定义i； extern int i = 1; // 定义 i，初始化抵消了 extern 的作用。              

变量只能被定义一次，但是可以多次声明。

声明和定义的区分很重要

c++是**静态类型语言**，其含义是**在编译阶段检查类型**。

**2.2.3 标识符**

标识符组成：字母、数字、下划线。不能以数字开头，对大小写敏感。标识符的长度没有限制。

用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。定义在函数体外的标识符不能以下划线开头。

变量命名规范：

1. 标识符要体现其实际含义。
2. 变量名一般用小写字母。
3. 用户自定义的类型一般以大写字母开头。
4. 包含多个单词的标识符，使用驼峰命名法或使用下划线连接不同单词。

对于嵌套作用域，可以在内层作用域中重新定义外层作用域已有的名字，但是最好不要这样做。

**2.3 复合类型**

复合类型就是基于其他类型定义的类型，引用和指针是其中两种。

**2.3.1 引用**

引用是给**对象**起的别名。初始化引用时，是将引用和对象绑定在一起。引用无法重定向，只能一直指向初始值。

**引用必须初始化。引用的初始值必须是一个对象，不能是字面值。**

对引用的所有操作都是对与之绑定的对象的操作。

**引用非对象。**

不能定义对引用的引用，因为引用非对象。

​                int &r = i;              

**引用只能绑定在对象上，不能与字面值或表达式绑定。**

引用只能绑定同类型对象。

**2.3.2 指针**

在块作用域内，指针如果没有被初始化，值将不确定。

指针必须指向指定的类型，不能指向其他类型。

​                int i = 0; double *dp = &i;   // 错误 long *lp = &i;     // 错误 int *ip = i;       // 这个也是错误的，但 int *ip = 0; 是正确的              

**指针与引用的不同：**

1. 指针是一个对象而引用不是；
2. 指针可以重定向引用不可以；
3. 有指向指针的指针无引用的引用；
4. 指针不需要在定义时赋初值而引用需要。

不能定义指向引用的指针。可以定义指向指针的引用。

​                int *p;  int* &r = p;      // r是对指针p的引用              

面对如上 *&r 这样比较复杂的指针或引用的声明语句时，从右向左读比较易于弄清。

利用解引用符（*）可以访问指针指向的对象。

**空指针**

​                int *p = nullptr; // 三种定义空指针的方式。最好用第一种 int *p = 0;  int *p = NULL;    // NULL 是在头文件 cstdlib 中定义的预处理变量，值为 0。              

**建议初始化所有指针。**

非零指针对应的条件值是 ture，零指针对应的条件值是 false。

**void\*指针**

void* 指针和空指针不是一回事。

void* 指针是特殊的指针类型，可以存放任意对象的地址。它的用处比较有限。

**2.3.3 理解复合类型的声明**

定义复合类型的变量要比定义基本类型的变量复杂很多。

一条声明语句是由一个基本数据类型和紧随其后的声明符列表组成的。

引用符 & 和指针符 * 都是类型说明符，类型说明符是声明符的一部分。

​                int &a=b, &c=b; int *a=nullptr, b=1;              

**2.4 const限定符**

**const 对象必须初始化**，因为一旦创建就不能再改变值。

默认情况下，const 对象仅在文件内有效。

如果想在多个文件间共享 const 对象，必须在变量的定义前添加 **extern** 关键字并在本文件中声明。**声明和定义都要加 extern**

**2.4.1 const的引用**

常量引用是对 const 的引用，对象不必是常量。对 const 对象的引用也必须是常量。

引用必须初始化，因此常量引用也必须初始化。

注意引用不是对象，因此常量引用不是说引用是常量，引用本来就只能绑定一个对象，而是引用不能改变引用的对象了。

​                const int ci = 42;  const int &r = ci;  // 用于声明引用的 const 都是底层 const              

不能用非常量引用指向一个常量对象。可以用常量引用指向一个非常量对象。

引用的类型必须与其所引用对象的类型一致，但是有两个例外。其中一个例外就是初始化常量引用时允许用任意表达式作为初始值（包括常量表达式），只要该表达式结果可以转换为引用的类型。

​                const int &r = 42;  // 常量引用可以绑定字面值              

当用常量引用绑定一个非常量对象时，不能通过引用改变引用对象的值，但是可以通过其他方式改变值。常量指针也一样。

**2.4.2 指针和const**

指向常量的指针的用法和常量引用相似，**但是是不一样的。**它既可以指向常量也可以指向非常量，不能改变对象的值。但是非常量对象可以通过其他途径改变值

**2.4.3 顶层const**

**顶层 const** 表示**指针本身**是个常量，**底层 const** 表示**指针所指的对象**是一个常量。顶层 const 对任何数据类型通用，**底层 const** 只用于引用和指针。

顶层 const 的指针表示该指针是 const 对象，因此必须初始化。底层 const 的指针则不用。

实际上只有指针类型既可以是顶层 const 也可以是底层 const，因为引用实际上只能是底层 const，常量引用即为底层 const，不存在顶层 const 的引用。

​                const int &const p2 = p1;// 错误              

从右向左读来判断是顶层 const 还是底层 const。

**对于指针和引用而言，顶层 const 在右边，底层 const 在左边。对于其他类型，全都是顶层 const**

​                const int* const p3 = p2; // 从右向左读，右侧const是顶层const，表明p3是一个常量，左侧const是底层const，表明指针所指的对象是一个常量 const int* p2 = &c;       // 这是一个底层const，允许改变 p2 的值 int* const p1 = &i;       // 这是一个顶层const，不能改变 p1 的值              

执行对象的拷贝操作时，不能将底层 const 拷贝给非常量，反之可以，非常量将会转化为常量。

**2.4.4 constexpr和常量表达式**

常量表达式是指**值不会改变**并且**在编译过程就能得到计算结果**的表达式。

**字面值属于常量表达式**，由常量表达式初始化的 const 对象也是常量表达式。

​                const int a = 32;          // 是常量表达式 const int b = a + 1;       // 是常量表达式 const int sz = get_size(); // 不是常量表达式，因为虽然 sz 是常量，但它的具体值等到运行时才知道。              

**cosntexpr变量**

在实际应用中很难分辨一个初始值是否是常量表达式，通过将变量声明为 **constexpr 类型**即可由编译器来检查。

**由 constexpr 声明的变量必须用常量表达式初始化。**

建议：如果认定一个变量是常量表达式，就把它声明为 constexpr 类型。

新标准允许定义 constexpr，这种函数应该足够简单以使得编译时就可以计算其结果。

不能用普通函数初始化 constexpr 变量，但可以使用 constexpr 函数初始化 constexpr 变量。

​                constexpr int sz = size(); //只有当 size() 是一个 constexpr 函数时这才是一条正确的声明语句。              

**字面值类型**

**算术类型、引用、指针都属于字面值类型**，自定义类则不属于。

cosntexpr 指针的初始值必须是 nullptr 或 0 或存储于固定地址的对象。函数体之外的对象和静态变量的地址都是固定不变的。

**指针和constexpr**

注意区分 constexpr 和 const 。constexpr 都是顶层 const，仅对指针本身有效。

​                const int *p = nullptr;     // p 是一个指向整型常量的指针 constexpr int *q = nullptr; // q 是一个指向整数的常量指针              

**区分const和constexpr**

constexpr 限定了变量是**编译器常量**，即变量的值在编译器就可以得到。

const 则并未区分是编译器常量还是运行期常量。即 const 变量可以在运行期间初始化，只是初始化后就不能再改变了。

**constexpr 变量是真正的“常量”**，而 const 现在一般只用来表示 **“只读”**。

**2.5 处理类型**

**2.5.1 类型别名**

有两种方法定义**类型别名**。

​                typedef double wages;  // 使用 typedef 关键字 using wages = double;  // 使用 using 关键字进行别名声明              

typedef 作为声明语句中的基本数据类型的一部分出现。含有 typedef 的声明语句定义的不再是变量而是类型别名。和其他声明语句一样，typedef 的声明语句中也可以包含类型修饰符，从而构造符合类型。

​                typedef wages base, *p; // base 是 double 的别名，p 是 double* 的别名。              

**指针、常量和类型别名**

​                typedef char* pstring;  const pstring cstr = 0; // 注意：const 是一个指向 char 的常量指针。不能采用直接替换的方式将其理解为 const char* cstr = 0，这是错误的。              

**2.5.2 auto类型说明符**

auto 说明符让编译器根据初始值来分析表达式所属的类型。理解：使用 auto 会增加编译时间，但不会增加运行时间。

auto 可以在一条语句中声明多个变量，但是多个变量必须是同一个基本数据类型（整型与整型指针和整型引用算一个类型）。

**复合类型、常量和auto**

编译器推断出的 auto 类型有时和初始值并不一样，编译器会进行适当的调整：

1. auto 根据引用来推断类型时会以引用对象的类型作为 auto 的类型。
2. auto 一般会忽略掉顶层 const，因此对于非指针类型的常量对象，auto 推断出的结果是不含 const 的。如果希望 auto 是一个顶层 const，需要明确指出。
3. auto 会保留底层 const。

概括一下就是 auto 会忽略引用与顶层 const。

​                const int ci = 1, cr = ci; auto b = ci;       // b 是一个普通的 int。 auto c = cr;       // c 是一个普通的 int。 const auto d = ci; // d 是一个 const int auto &e = ci;      // e 是一个常量引用（常量引用是底层 const）。注意这个微妙的地方。 auto f = &ci;      // f 是一个 const int*（位于左边的 const 是底层 const）              

int 与 int *、int & 是一个基本数据类型，而 const int 与 int 不是一种类型。

用 auto 定义引用时，必须用 & 指明要定义的是引用。

**2.5.3 decltype类型指示符**

当希望获得表达式的类型但是不要值的时候，可以使用类型说明符 decltype。

如果 decltype 使用的表达式是一个变量，则它返回该变量的类型（**包括顶层 const 和引用在内**）。

decltype 与 auto 的不同：decltype 不会忽略引用和顶层 const。

**注意当获得的类型是引用时，必须初始化。**

​                const int ci = 0, &cj = ci; decltype(ci) x = 0;  // x 的类型是 const int decltype(cj) y = x;  // y 的类型是 const int& decltype(cj) z; // z 是一个引用，必须初始化              

引用从来都是作为对象的别名出现，只有在 decltype 处是例外。

**decltype 和引用**

如果 decltype 使用的表达式不是一个变量，则 decltype 返回**表达式结果对应的类型**。可以使用这种方式来保证不获取引用类型。

注意**解引用指针的结果**是一个引用类型。**给变量加括号的结果**也是引用类型。**赋值操作的结果**也是引用类型。

​                int i = 42, &r = i, *p; decltype(r+0) b;      // b 的类型是 int，因为 r+0 的结果类型是 int。 decltype(*p) c = i;   // c 的类型是 int&。 decltype((i)) d = i;  // d 的类型是 int&。              

decltype((var)) 的结果永远是引用，而 decltype(var) 的结果只有当 var 本身就是引用时才是引用。

**2.6 自定义数据结构**

**2.6.1 定义sales_data类型**

struct+类名+类体+**分号。**类体可以为空。

​                struct Sales_data{};   // 注意：结尾加分号              

定义类时可以给数据成员提供**类内初始值**以进行初始化。没有类内初始值的成员则被默认初始化。

类内初始值可以放在花括号中或等号的右边，不能使用圆括号。

**2.6.3 编写自己的头文件**

类通常定义在头文件中，类所在头文件的名字应与类的名字一样。

头文件通常定义那些**只能被定义一次的实体**，比如类、const、constexpr 等。

头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。

**预处理器概述**

确保头文件多次包含仍能安全工作的常用技术是预处理器。

预处理变量有两种状态：已定义和未定义。一般把预处理变量的名字全部大写。

整个程序中的预处理变量包括头文件保护符必须唯一，通常基于头文件中类的名字来构建保护符的名字，以确保其唯一性。

c++ 中包含三个**头文件保护符****：**

1. \#define：把一个名字设定为预处理变量
2. \#ifndef：当且仅当变量已定义时为真，一旦检查结果为真，则执行后续操作直到遇到 #endif 为止
3. \#endif

预处理变量无视作用域的规则，作用范围是文件内