# RPC面试题

## 面试题

### **01 什么是RPC?**

RPC (Remote Producedure Call) 指过程远程调用，主要用于异构的分布式系统之间的通信。

RPC的主要目标：尽量保证提供类似本地调用的简洁语义的基础上，让分布式应用之间的通信变得更加方便和高效。

RPC框架需要提供一种透明调用机制，使得调用者无须显式地区分本地调用和远程调用，同时基于 RPC 使得服务治理（服务限流、服务熔断等）更加方便。

### **02 RPC被广泛使用的主要原因**

（1）随着业务复杂化和系统拆分，微服务构建和分布式部署已经成为常态，而分布式系统之间的



### **03 RPC包含哪些部分**

（1）客户端和服务端建立网络连接模块（server模块，client模块）

（2）服务端处理请求模块

（3）协议模块

（4）序列化和反序列化模块

### **04 设计一个RPC需要考虑哪些问题**

设计一个RPC框架，可以从RPC包含的几个模块去考虑，对每一个模块分别进行设计：

（1）客户端和服务端如何建立网络连接？

（2）服务端如何处理请求i？

（3）数据传输采用什么协议？

（4）数据该如何序列化和反序列化？

![gRPC架构](.\img\efd86e87-45a1-4cd0-ba14-2b11f263c8e0.png)

### **05 RPC的几个核心组件**

RPC框架包含4个核心组件：客户端（Client）、客户端存根（Client Stub）、服务端（Server）及服务端存根（Server Stub）

- 客户端：服务的调用者
- 客户端存根：存放服务端的服务列表，将客户端请求打包并通过网络发送到服务端。
- 服务端：服务提供者
- 服务端存根：接收客户端消息并解包，然后调用本地的方法。

### 06 RPC的调用过程主要包括哪些？

建立通信(开放协议、私有协议)、服务寻址、网络传输(http、socket)、服务调用和返回（序列化和反序列化）

如图是一个典型的RPC调用的详细流程：

![img](.\img\c0e1a365547ca130a12409f3aa2f0282.png)

### 07 服务端如何处理请求？有哪些方式？

服务端接收到客户端的请求后，常见的处理方式有三种：BIO ,NIO和AIO

(1) 同步阻塞方式（BIO 即blocking IO）: 一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理,线程开销大。

(2) 同步非阻塞方式（NIO 即New IO）:  也叫做“non-blocking IO” 即非阻塞IO ，一个请求一个线程，客户端发送的连接请求会注册到[多路复用器](https://blog.csdn.net/m0_67318913/article/details/138442134)上，多路复用器轮询到该连接有I/O请求时才启动一个线程进行处理；

(3) 异步非阻塞方式（AIO）:一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。

三者的特点分别是：

- BIO是面向流的，NIO是面向缓冲区的；
- BIO是各种流是阻塞的，而NIO是非阻塞的；
- BIO的Stream是单向的，而NIO的channel是双向的
- NIO：事件驱动模型、单线程处理多任务、非阻塞I/O，I/O读写不再阻塞，而是返回0、基于block的传输比基于流的传输更高效、更高级的IO函数zero-copy、IO多路复用大大提高了Java网络应用的可伸缩性和实用性。基于Reactor线程模型

> **使用场景**
>
> BIO : 适用于连接数比较小的业务场景，这样的话不至于系统中没有可用线程去处理请求。这种方式写的程序也比较简单直观，易于理解。
>
> NIO 适用于连接数比较多并且请求消耗比较轻的业务场景，比如聊天服务器。这种方式相比 BIO，相对来说编程比较复杂。
>
> AIO 适用于连接数比较多而且请求消耗比较重的业务场景，比如涉及 I/O 操作的相册服务器。这种方式相比另外两种，编程难度最大，程序也不易于理解。

### 08 序列化与反序列的方式有哪些

- **序列化**： 将数据结构或对象转换成二进制字节流的过程
- **反序列化**：将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程

序列化常见分为两类：

- 文本类： xml/json
- 二进制类：hessian，kryo，Protobuf ，扩展学习：[深入理解 RPC 之序列化篇](https://lexburner.github.io/rpc-serialize-1/)



值得注意，RPC通信流程中网络传输的数据必须是二进制数据，调用方请求的出入参数则是对象。

### 09 有哪些序列化协议？

|                    | 优点                                     | 缺点                                                         |
| ------------------ | ---------------------------------------- | ------------------------------------------------------------ |
| kryo               | 速度快，序列化后体积小                   | 跨语言支持较复杂                                             |
| hessian            | 默认支持跨语言                           | 较慢                                                         |
| protostuff         | 速度快，基于protobuf                     | 需静态编译                                                   |
| protostuff-runtime | 无需静态编译，但序列化前需预先传入schema | 不支持无默认构造函数的类，反序列化时需用户自己初始化序列化后的对象，其只负责将该对象进行赋值 |
| Java               | 使用方便，可序列化所有类                 | 速度慢，占空间                                               |

参考扩展代码：https://www.kancloud.cn/littlelittlebear/guide-rpc-framework/2097799

### 10 为什么要进行序列化和反序列化？

（1）需要解决内存中数据结构到字节序列的映射过程中，如何保留各个结构和字段间的关系而生的技术。

（2）解决异构系统的数据传输，比如大小端，远端的持久存储；

（3）压缩数据，加快网络传输 【网络传输耗时一方面取决于网络带宽大小，另一方面取决于数据传输量。想加快网络传输，要么提高带宽，要么减小数据传输量，而对数据进行编码的主要目的就是减小数据传输量】

### 11 实现高性能的RPC关键在于哪些方面？

(1) 降低通信开销

**数据压缩**：通过使用如gzip、LZ4等压缩算法减少数据传输量

(2) 提高处理速度

**负载均衡**：将请求分发到多个服务器上，防止单个服务器过载，从而提高系统吞吐量

(3)缓存优化、

将经常访问的数据缓存在服务器端，减少数据库访问次数，从而加快响应速度。

(4)协议优化

使用高效的通信协议（如Thrift、Protocol Buffers等）减少序列化/反序列化开销。这些协议通常具有更小的数据表示和更高效的编解码过程。

(5) 心跳检测、

通过实现节点与注册中心的心跳检测功能，确保服务节点的可用性和系统的稳定性。心跳检测可以定期发送心跳包以确认服务节点的状态。

(6) 通信协议与序列化

选择稳定可靠的通信协议，如TCP、HTTP或HTTP2。对于RPC框架来说，通信协议应该尽可能简单以减少编解码的性能损耗。同时，采用高效的序列化方式，如二进制序列化，以提高数据传输效率。

(7)动态配置管理

支持服务配置的动态修改，并将更新后的配置推送到客户端和服务端，无需重启任何服务。这可以提高系统的灵活性和可维护性。

(8) 错误处理与监控

实现完善的错误处理机制，确保在发生错误时能够迅速定位问题并进行修复。同时，通过监控工具对RPC调用的性能进行实时监控和分析，以便及时发现问题并进行优化。



### 12 TCP协议和HTTP协议的优缺点

以下是TCP协议和HTTP协议的优缺点对比表格：



| 协议     | 优点                                                         | 缺点                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| TCP协议  | 1. 可靠性：通过三次握手、确认（ACK）和重传机制确保数据完整性和正确性。<br>2. 流量控制：通过滑动窗口机制实现，避免发送方发送过快导致接收方处理不过来。<br>3. 拥塞控制：内置拥塞控制算法，减轻网络负担。<br>4. 有序传输：通过序列号和确认应答机制保证数据包的有序传输。 | 1. 传输效率：面对网络丢包和延迟时，会降低传输速率。<br>2. 握手和慢启动：建立连接需要三次握手，且慢启动机制影响初始传输速度。<br>3. 资源消耗：在发送端和接收端维护复杂的状态信息和定时器，消耗系统资源。 |
| HTTP协议 | 1. 高灵活性和可扩展性：从HTTP1.0到HTTP2.x不断扩展新属性。<br>2. 可靠传输：基于TCP协议，具有可靠传输的特点。<br>3. 请求应答：客户端发送请求，服务器返回响应。<br>4. 无状态：请求独立，有利于缓存和服务器资源管理。 | 1. 明文传输不安全：容易被窃听和篡改，不适合传输敏感信息。<br>2. 对头阻塞：复用一个TCP连接时可能发生，影响性能。<br>3. 无状态：在长连接时需要保存大量上下文，增加服务器负担。 |

### 13 在 RPC 里面，我们是怎么实现请求跟响应关联的？

RPC的协议包括三个内容：固定部分、协议头内容，协议体内容，前两部分可以统称“协议头”，

如下是一个用于演示的协议结构：

![image-20240622171117258](.\img\image-20240622171117258.png)

在RPC中，请求与响应的关联是通过消息ID实现的，以区分响应消息对应的是哪条请求消息。在没有动态代理的情况下，可以采用代码生成的Service存根来代替动态代理。在gRPC调用中，返回InputStream而不

### 14 RPC 框架中如何选择序列化？

在RPC框架中选择序列化方式时，需要考虑多个因素以确保系统的性能、安全性、易用性和可扩展性。以下是一些在选择RPC框架序列化方式时应考虑的关键点：

1. 通用性：序列化框架是否支持跨语言、跨平台。这对于构建分布式系统或微服务架构至关重要，因为不同的服务可能使用不同的编程语言或平台。
2. 性能
   - 序列化和反序列化的时间开销：选择编解码速度快的序列化协议可以提高系统的整体性能。
   - 序列化后的数据大小：对于网络传输来说，数据大小是一个重要的指标。较小的序列化数据可以减少网络带宽的占用和传输时间。
3. 易用性
   - 序列化框架是否易于使用、调试和维护。易用性会影响开发效率和系统的稳定性。
4. 可扩展性
   - 随着业务的发展，传输的实体可能会发生变化。选择的序列化框架应具有良好的扩展性，以支持新的数据类型和结构。
5. 安全性
   - 考虑序列化数据的机密性、完整性和可用性。某些序列化协议可能包含已知的安全漏洞，因此需要谨慎选择。
6. 数据类型和语法支持
   - 不同序列化框架所支持的数据类型和语法结构可能有所不同。选择能够支持项目所需数据类型和语法的序列化框架非常重要。
7. 兼容性
   - 如果你的系统需要与现有的系统或服务进行交互，确保所选的序列化方式与这些系统或服务兼容。
8. 序列化协议
   - 根据项目的具体需求，选择适合的序列化协议。例如，对于Java项目，JDK原生序列化、Protocol Buffers、Hessian、JSON、XML等都是常见的选择。每种协议都有其优缺点，需要根据项目的实际情况进行评估。
9. 版本控制（如JDK序列化中的serialVersionUID）：
   - 对于需要支持版本控制的序列化框架，确保能够正确处理不同版本之间的兼容性。例如，在JDK序列化中，serialVersionUID用于检查序列化对象的版本是否一致。
10. 工具和支持
    - 考虑是否有可用的工具和库来支持所选的序列化方式。这些工具和库可以帮助简化开发过程并提高系统的可维护性。

![image-20240622173054079](.\img\image-20240622173054079.png)

综合几个参考因素：首选 hessian 和 protobuf。



### RPC框架在使用时要注意哪些问题？

（1）对象要尽量简单，没有太多的依赖关系，属性不能太多，尽量高内聚

（2）入参对象与返回值对象体积不要太大，更不要传太大啊的集合。

（3）尽量使用简单的，常用的，开发语言原生的对象，尤其是集合类；

（4）对象不能有复杂的继承关系，最好不要有父子类



## 参考资料

1. https://cloud.tencent.com/developer/article/2117513