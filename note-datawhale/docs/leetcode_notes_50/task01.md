# task01: 数据结构与算法简介、leetcode入门及攻略

## 1、数据结构与算法

**数据结构是程序的骨架，而算法则是程序的灵魂。**

**程序  = 算法 + 数据结构**

- 算法：解决问题的方法或者过程
- 数据结构：是数据的计算机表示和相应的一组操作
- 程序：算法和数据结构的具体实现

> **为什么要学习算法和数据结构？**
>
> 学习算法和数据结构，是为了学会在编程中从时间复杂度、空间复杂度方面考虑解决方案，训练自己的逻辑思维，从而写出高质量的代码，以此提升自己的编程技能，获取更高的工作回报。

### 1.1 数据结构

> 数据结构（Data Structure）： 带有结构特性的数据元素的集合。

简单而言，**数据结构** 是指 数据的**组织结构、用来组织、存储数据。**

数据结构研究的是数据的**逻辑结构、物理结构**以及它们之间的相互关系，并对这种结构定义相应的运算。

我们可以按照数据的**逻辑结构和物理结构**来进行分类

#### 1.1.1 数据的逻辑结构

> 逻辑结构（Logical Structure）: 数据元素之间的相互关系

数据的逻辑结构分为以下四种：

1. **集合结构** 

   **特点：**

   - 数据元素属于一个集合，除此之外无其他关系。
   - 集合结构中的数据元素无序、并且每个数据元素都是唯一的，集合中没有相同的数据元素。

   

![image-20230912095941605](.\img\image-20230912095941605.png)

2. **线性结构**

   **特点：**

   - 数据之间是一对一关系
   - 线性结构中的数据元素（除了第一个和最后一个元素），左侧和右侧分别只有一个数据与其相邻。线性结构类型包括：**数组、链表，以及由它们衍生出来的栈、队列、哈希表**。

   ![image-20230912101124849](.\img\image-20230912101124849.png)

3. **树形结构**

   **特点**

   - 数据元素之间是「一对多」的层次关系。
   - 最简单的树形结构是二叉树。这种结构可以简单的表示为：根， 左子树， 右子树。 左子树和右子树又有自己的子树。当然除了二叉树，树形结构类型还包括：多叉树、字典树等。

   ![image-20230912101153647](.\img\image-20230912101153647.png)

4. **图形结构**

   特点：

   - 数据元素之间是「多对多」的关系。

   - 图形结构是一种比树形结构更复杂的非线性结构，用于表示物件与物件之间的关系。一张图由一些小圆点（称为 **「顶点」** 或 **「结点」**）和连结这些圆点的直线或曲线（称为 **「边」**）组成。

     在图形结构中，任意两个结点之间都可能相关，即结点之间的邻接关系可以是任意的。图形结构类型包括：无向图、有向图、连通图等。

![image-20230912101332003](.\img\image-20230912101332003.png)

#### 1.1.2 数据的物理结构

物理结构（Physical Structure）:  数据的逻辑结构在计算机中的存储方式。

计算机内有多种存储结构，采用最多的是这两种结构：**「顺序存储结构」**、**「链式存储结构」**。



1. **顺序存储结构**

​    **定义：**将数据元素存放在一片地址连续的存储单元里，数据元素之间的逻辑关系通过数据元素的存储地址来直接反映。

​	**特点：**

	-  在顺序存储结构中，逻辑上相邻的数据元素在物理地址上也必然相邻 。
	-  简单、易理解，且实际占用最少的存储空间。
	-  需要占用一片地址连续的存储单元；并且存储分配要事先进行；另外对于一些操作的时间效率较低（移动、删除元素等操作）。

![image-20230912102143964](.\img\image-20230912102143964.png)

2. **链式存储结构**

   **定义：**将数据元素存放在任意的存储单元里，存储单元可以连续，也可以不连续。

![image-20230912140549440](.\img\image-20230912140549440.png)

链式存储结构中，逻辑上相邻的数据元素在物理地址上可能相邻，可也能不相邻。其在物理地址上的表现是随机的。

链式存储结构中，一般将每个数据元素占用的若干单元的组合称为一个链结点。每个链结点不仅要存放一个数据元素的数据信息，还要存放一个指出这个数据元素在逻辑关系的直接后继元素所在链结点的地址，该地址被称为指针。换句话说，数据元素之间的逻辑关系是通过指针来间接反映的。



**优点：**存储空间不必事先分配，在需要存储空间的时候可以临时申请，不会造成空间的浪费；一些操作的时间效率远比顺序存储结构高（插入、移动、删除元素）。

**缺点：**不仅数据元素本身的数据信息要占用存储空间，指针也需要占用存储空间，链式存储结构比顺序存储结构的空间开销大。

### 1.2 算法

算法（Algorithm）:  解决特定问题求解步骤的准确而完整的描述，在计算中表现为一系列指令的集合，算法代表着用系统的方法描述解决问题的策略机制。

简单而言，**算法**指的是解决问题的方法。

算法可以用自然语言、编程语言（Python、C、C++、Java等）描述，也可以用**伪流程、流程图**来表示。

#### 1.2.1 算法基本特性

- 输入
- 输出
- 有穷性
- 确定性
- 可行性

#### 1.2.2 算法追求的目标

不同的算法成本不同，一个优秀的算法至少应该追求以下两个目标：

1. **所需运行时间更少（时间复杂度更低）**
2. **占用内存空间更小（空间复杂度更低）**

一个好的算法还应该追求以下目标：

1. **正确性**：正确性是指算法能够满足具体问题的需求，程序运行正常，无语法错误，能够通过典型的软件测试，达到预期的需求。
2. **可读性**：可读性指的是算法遵循标识符命名规则，简洁易懂，注释语句恰当，方便自己和他人阅读，便于后期修改和调试。
3. **健壮性**：健壮性指的是算法对非法数据以及操作有较好的反应和处理。

这 3 个目标是算法的基本标准，是所有算法所必须满足的。一般我们对好的算法的评判标准就是上边提到的 **所需运行时间更少（时间复杂度更低）**、**占用内存空间更小（空间复杂度更低）**。

### 1.3 数据结构小结

#### 1.3.1 数据结构总结

数据结构分为 **逻辑结构** 和 **物理结构**。

- 逻辑结构分为：**集合结构**、**线性结构**、**树形结构**、**图形结构**。
- 物理结构分为：**顺序存储结构**、**链式存储结构**。

逻辑结构指的是数据之间的 **关系**，物理结构指的是这种关系 **在计算机中的表现形式**。

>  例如：线性表中的「栈」，其数据元素之间的关系是一对一的，除头和尾结点之外的每个结点都有唯一的前驱和唯一的后继，这体现的是逻辑结构。而对于栈中的结点来说，可以使用顺序存储（也就是 **顺序栈**）的方式存储在计算机中，其结构在计算机中的表现形式就是一段连续的存储空间，栈中每个结点和它的前驱结点、后继结点在物理上都是相邻的。当然，栈中的结点也可以使用链式存储（也即是 **链式栈**），每个结点和它的前驱结点、后继结点在物理上不一定相邻，每个结点是靠前驱结点的指针域来进行访问的。

#### 1.3.2 算法总结

**算法** 指的就是解决问题的方法。

算法是一系列的运算步骤，这些运算步骤可以解决特定的问题。

算法拥有 5 个基本特性：**输入**、**输出**、**有穷性**、**确定性**、**可行性**。

算法追求的目标有 5 个：**正确性**、**可读性**、**健壮性**、**所需运行时间更少（时间复杂度更低）**、**占用内存空间更小（空间复杂度更低）**。

## 2、算法复杂度

**定义：**

算法复杂度（Algorithm complexity）： 在问题的输入规模为n的条件下，程序的时间使用情况和空间使用情况。

算法所追求的就是 **所需运行时间更少（时间复杂度更低）**、**占用内存空间更小（空间复杂度更低）**

算法分析，就是从**运行时间情况、空间使用情况**两方面对算法进行分析。

比较算法的两种方法：

1. 事后统计
2. 预先统计（推荐），**不考虑编程语言，计算机运行速度，只关心随着问题规模 $n$ 扩大时，时间开销、空间开销的增长情况**。

>  **问题规模 $n：$** ：算法问题输入的数据量大小。
>
> - 排序算法中：  $n$表示需要排序的元素数量。
> - 查找算法中： $n$ 表示查找范围内的元素总数：比如数组大小、二维矩阵大小、字符串长度、二叉树节点数、图的节点数、图的边界点等。
> - 二进制计算相关算法中： $n$ 表示二进制的展开宽度。

### 2.1 时间复杂度

定义：

**时间复杂度（Time Complexity）**：在问题的输入规模为 $n$ 的条件下，算法运行所需要花费的时间，可以记作为 $T(n)$。

**基本操作** ：算法执行中的每一条语句。每一次基本操作都可在常数时间内完成。基本操作是一个运行时间不依赖于操作数的操作。

**举例：**

```python
def algorithm(n):
    fact = 1                +++++ 1 
    for i in range(1,n+1):  +++++ n
        fact *= i			+++++ n
    return fact 			+++++ 1 
```

上述算法的执行次数： $2n+2$ ,用f(n)表示： $f(n) = 2n +2$

**时间复杂度：**$T(n) = O(f(n))$。 它表示的是随着问题规模 n 的增大，算法执行时间的增长趋势跟  $f(n)$相同。

$O$是一种渐进符号，$T(n)$称作算法的渐进时间复杂度（Asymptotic Time Complexity）,简称为时间复杂度。



#### 2.1.1 渐进符号

> 渐进符号（Asymptotic Symbol）:刻画函数的增长速度，并且只保留**最高阶幂**。忽略**低阶幂**、**系数**、**常量**等。

经常用到的渐进符号有三种： **Θ 渐进紧确界符号、$O$渐进上界符号、Ω 渐进下界符号**。



### 2.2 空间复杂度

> **空间复杂度（Space Complexity）**：在问题的输入规模为 $n$ 的条件下，算法所占用的空间大小，可以记作为$S(n)$。一般将 **算法的辅助空间** 作为衡量空间复杂度的标准。

除了执行时间的长短，算法所需储存空间的多少也是衡量性能的一个重要方面。而在「2. 时间复杂度」中提到的渐进符号，也同样适用于空间复杂度的度量。空间复杂度的函数可以表示为 $ S(n) = O(f(n))$，它表示的是随着问题规模 $n$ 的增大，算法所占空间的增长趋势跟 $f(n)$ 相同。

相比于算法的时间复杂度计算来说，算法的空间复杂度更容易计算，主要包括「局部变量（算法范围内定义的变量）所占用的存储空间」和「系统为实现递归（如果算法是递归的话）所使用的堆栈空间」两个部分。

### [2.3 算法复杂度小结](https://datawhalechina.github.io/leetcode-notes/#/ch01/01.01/01.01.02-Algorithm-Complexity?id=算法复杂度总结)

**「算法复杂度」** 包括 **「时间复杂度」** 和 **「空间复杂度」**，用来分析算法执行效率与输入问题规模 $n$ 的增长关系。通常采用 **「渐进符号」** 的形式来表示「算法复杂度」。

常见的时间复杂度有：$O(1)$、$O(\log n)$、$O(n)$、$O(n \times \log n)$、$O(n^2)$、$O(n^3)$、$O(2^n)$、$O(n!)$。

常见的空间复杂度有：$O(1)$、$O(\log n)$、$O(n)$、$O(n^2)$。

## 3、LeetCode练习题5道

#### 1. [2235. 两整数相加](https://leetcode.cn/problems/add-two-integers/)

```python
def twoSum(self, nums: List[int], target: int) -> List[int]:
    numDict = dict()
    for i in range(len(nums)):
        if target-nums[i] in numDict:
            return numDict[target-nums[i]], i
        numDict[nums[i]] = i
    return [0]
```



#### 2. [1929. 数组串联](https://leetcode.cn/problems/concatenation-of-array/)

```python
class Solution:
    def getConcatenation(self, nums: List[int]) -> List[int]:
        nums.extend(nums)
        return nums
```



#### 3.[0771. 宝石与石头](https://leetcode.cn/problems/jewels-and-stones/)

```python
class Solution(object):
    def numJewelsInStones(self, J, S):
        res = 0
        j_arr = []
        for c in J:
            j_arr.append(c)
        for c in S:
            if c in j_arr:
                res += 1
        return res

```



#### 4.[1480. 一维数组的动态和](https://leetcode.cn/problems/running-sum-of-1d-array/)

```python
class Solution(object):
    def runningSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        lis = []
        sum = 0
        for i in nums:
            sum+=i
            lis.append(sum)    
        return lis
        

```



#### 5.[0709. 转换成小写字母](https://leetcode.cn/problems/to-lower-case/)

```python
class Solution:
    def toLowerCase(self, str: str) -> str:
        new_ch_list=[]
        for ch in str:
            if 65<=ord(ch)<97:
                new_ch_list.append(chr(ord(ch)+32))
            else:
                new_ch_list.append(ch)
        return "".join(new_ch_list)

```



#### 6.[1672. 最富有客户的资产总量](https://leetcode.cn/problems/richest-customer-wealth/)

```python
class Solution(object):
    def maximumWealth(self, accounts):
        """
        :type accounts: List[List[int]]
        :rtype: int
        """
        maxm = 0
        for i in accounts:
            if maxm < sum(i):
                maxm = sum(i)
        return maxm

```

